"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventSubListener = void 0;
const tslib_1 = require("tslib");
const logger_1 = require("@d-fischer/logger");
const raw_body_1 = require("@d-fischer/raw-body");
const shared_utils_1 = require("@d-fischer/shared-utils");
const auth_1 = require("@twurple/auth");
const common_1 = require("@twurple/common");
const httpanda_1 = require("httpanda");
const EventSubChannelBanSubscription_1 = require("./subscriptions/EventSubChannelBanSubscription");
const EventSubChannelCheerSubscription_1 = require("./subscriptions/EventSubChannelCheerSubscription");
const EventSubChannelFollowSubscription_1 = require("./subscriptions/EventSubChannelFollowSubscription");
const EventSubChannelHypeTrainBeginSubscription_1 = require("./subscriptions/EventSubChannelHypeTrainBeginSubscription");
const EventSubChannelHypeTrainEndSubscription_1 = require("./subscriptions/EventSubChannelHypeTrainEndSubscription");
const EventSubChannelHypeTrainProgressSubscription_1 = require("./subscriptions/EventSubChannelHypeTrainProgressSubscription");
const EventSubChannelRaidSubscription_1 = require("./subscriptions/EventSubChannelRaidSubscription");
const EventSubChannelRedemptionAddSubscription_1 = require("./subscriptions/EventSubChannelRedemptionAddSubscription");
const EventSubChannelRedemptionUpdateSubscription_1 = require("./subscriptions/EventSubChannelRedemptionUpdateSubscription");
const EventSubChannelRewardAddSubscription_1 = require("./subscriptions/EventSubChannelRewardAddSubscription");
const EventSubChannelRewardRemoveSubscription_1 = require("./subscriptions/EventSubChannelRewardRemoveSubscription");
const EventSubChannelRewardUpdateSubscription_1 = require("./subscriptions/EventSubChannelRewardUpdateSubscription");
const EventSubChannelSubscriptionSubscription_1 = require("./subscriptions/EventSubChannelSubscriptionSubscription");
const EventSubChannelUnbanSubscription_1 = require("./subscriptions/EventSubChannelUnbanSubscription");
const EventSubChannelUpdateSubscription_1 = require("./subscriptions/EventSubChannelUpdateSubscription");
const EventSubStreamOfflineSubscription_1 = require("./subscriptions/EventSubStreamOfflineSubscription");
const EventSubStreamOnlineSubscription_1 = require("./subscriptions/EventSubStreamOnlineSubscription");
const EventSubUserAuthorizationRevokeSubscription_1 = require("./subscriptions/EventSubUserAuthorizationRevokeSubscription");
const EventSubUserUpdateSubscription_1 = require("./subscriptions/EventSubUserUpdateSubscription");
const numberRegex = /^\d+$/;
/**
 * A listener for the Twitch EventSub event distribution mechanism.
 */
let EventSubListener = class EventSubListener {
    /**
     * Creates a new EventSub listener.
     *
     * @param apiClient The ApiClient instance to use for user info and API requests.
     * @param secret The secret for Twitch to sign payloads with.
     * @param adapter The connection adapter.
     * @param config
     */
    constructor(apiClient, adapter, secret, config) {
        this._subscriptions = new Map();
        this._twitchSubscriptions = new Map();
        if (apiClient._authProvider.tokenType !== 'app') {
            throw new auth_1.InvalidTokenTypeError('EventSub requires app access tokens to work; please use the ClientCredentialsAuthProvider in your API client.');
        }
        this._apiClient = apiClient;
        this._secret = secret;
        this._adapter = adapter;
        this._logger = new logger_1.Logger({
            name: '@twurple/eventsub',
            emoji: true,
            ...config === null || config === void 0 ? void 0 : config.logger
        });
    }
    /**
     * Starts the backing server and listens to incoming EventSub notifications.
     */
    async listen(port) {
        var _a;
        if (this._server) {
            throw new Error('Trying to listen while already listening');
        }
        const server = this._adapter.createHttpServer();
        this._server = new httpanda_1.Server({
            server,
            onError: (e, req) => {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                if (e.code === 404) {
                    this._logger.warn(`Access to unknown URL/method attempted: ${req.method} ${req.url}`);
                }
            }
        });
        // needs to be first in chain but run last, for proper logging of status
        this._server.use((req, res, next) => {
            setImmediate(() => {
                this._logger.debug(`${req.method} ${req.path} - ${res.statusCode}`);
            });
            next();
        });
        this._server.post('/:id', this._createHandleRequest());
        const adapterListenerPort = await this._adapter.getListenerPort();
        if (adapterListenerPort && port) {
            this._logger.warn(`Your passed port (${port}) is being ignored because the adapter has overridden it.
Listening on port ${adapterListenerPort} instead.`);
        }
        const listenerPort = (_a = adapterListenerPort !== null && adapterListenerPort !== void 0 ? adapterListenerPort : port) !== null && _a !== void 0 ? _a : 443;
        await this._server.listen(listenerPort);
        this._currentListenerPort = listenerPort;
        this._logger.info(`Listening on port ${listenerPort}`);
        await this.resumeExistingSubscriptions();
    }
    /**
     * Resumes subscriptions that are already registered with Twitch.
     */
    async resumeExistingSubscriptions() {
        const subscriptions = await this._apiClient.helix.eventSub.getSubscriptionsPaginated().getAll();
        const urlPrefix = await this._buildHookUrl('');
        this._twitchSubscriptions = new Map(subscriptions
            .map((sub) => {
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (sub._transport.method === 'webhook') {
                const url = sub._transport.callback;
                if (url.startsWith(urlPrefix)) {
                    const id = url.slice(urlPrefix.length);
                    return [id, sub];
                }
            }
            return undefined;
        })
            .filter((x) => !!x));
        await Promise.all([...this._subscriptions].map(async ([subId, sub]) => await sub.start(this._twitchSubscriptions.get(subId))));
    }
    /**
     * Stops the backing server, suspending all active subscriptions.
     */
    async unlisten() {
        if (!this._server) {
            throw new Error('Trying to unlisten while not listening');
        }
        await Promise.all([...this._subscriptions.values()].map(async (sub) => await sub.suspend()));
        await this._server.close();
        this._server = undefined;
        this._currentListenerPort = undefined;
    }
    /**
     * Applies middleware that handles EventSub notifications to a connect-compatible app (like express).
     *
     * The express app should be started before this.
     *
     * @param app The app the middleware should be applied to.
     */
    async applyMiddleware(app) {
        let { pathPrefix } = this._adapter;
        if (pathPrefix) {
            pathPrefix = `/${pathPrefix.replace(/^\/|\/$/, '')}`;
        }
        const paramParser = (req, res, next) => {
            const [, id] = req.path.split('/');
            req.param = req.params = { id };
            next();
        };
        const requestHandler = this._createHandleRequest();
        if (pathPrefix) {
            app.use(pathPrefix, paramParser, requestHandler);
        }
        else {
            app.use(paramParser, requestHandler);
        }
        // stub to fix subscription registration
        this._currentListenerPort = -1;
    }
    /**
     * Subscribes to events representing a stream going live.
     *
     * @param user The user for which to get notifications about their streams going live.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToStreamOnlineEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToStreamOnlineEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubStreamOnlineSubscription_1.EventSubStreamOnlineSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events representing a stream going offline.
     *
     * @param user The user for which to get notifications about their streams going offline.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToStreamOfflineEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToStreamOfflineEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubStreamOfflineSubscription_1.EventSubStreamOfflineSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events representing a change in channel metadata, e.g. stream title or category.
     *
     * @param user The user for which to get notifications about updates.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelUpdateEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelUpdateSubscription_1.EventSubChannelUpdateSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user following a channel.
     *
     * @param user The user for which to get notifications about their followers.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelFollowEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelFollowEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelFollowSubscription_1.EventSubChannelFollowSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user subscribing to a channel.
     *
     * @param user The user for which to get notifications for about their subscribers.
     * @param handler  The function that will be called for any new notifications.
     */
    async subscribeToChannelSubscriptionEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelSubscribeEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelSubscriptionSubscription_1.EventSubChannelSubscriptionSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user cheering some bits.
     *
     * @param user The user for which to get notifications for about cheers they get.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelCheerEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelCheerEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelCheerSubscription_1.EventSubChannelCheerSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user getting banned from a channel.
     *
     * @param user The user for which to get notifications for when users get banned in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelBanEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelBanEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelBanSubscription_1.EventSubChannelBanSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user getting unbanned from a channel.
     *
     * @param user The user for which to get notifications for when users get unbanned in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelUnbanEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelUnbanEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelUnbanSubscription_1.EventSubChannelUnbanSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a broadcaster raiding another broadcaster.
     *
     * @param user The broadcaster for which to get outgoing raid notifications.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRaidEventsFrom(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelRaidEventsFrom: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRaidSubscription_1.EventSubChannelRaidSubscription, handler, this, userId, 'from');
    }
    /**
     * Subscribes to events that represent a broadcaster being raided by another broadcaster.
     *
     * @param user The broadcaster for which to get incoming raid notifications.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRaidEventsTo(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelRaidEventsTo: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRaidSubscription_1.EventSubChannelRaidSubscription, handler, this, userId, 'to');
    }
    /**
     * Subscribes to events that represent a Channel Points reward being added to a channel.
     *
     * @param user The user for which to get notifications for when they add a reward to their channel.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRewardAddEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelRewardAddEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRewardAddSubscription_1.EventSubChannelRewardAddSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a Channel Points reward being updated.
     *
     * @param user The user for which to get notifications for when they update a reward.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRewardUpdateEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToRewardUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRewardUpdateSubscription_1.EventSubChannelRewardUpdateSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a specific Channel Points reward being updated.
     *
     * @param user The user for which to get notifications for when they update the reward.
     * @param rewardId The ID of the reward for which to get notifications when it is updated.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRewardUpdateEventsForReward(user, rewardId, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToRewardUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRewardUpdateSubscription_1.EventSubChannelRewardUpdateSubscription, handler, this, userId, rewardId);
    }
    /**
     * Subscribes to events that represent a Channel Points reward being removed.
     *
     * @param user The user for which to get notifications for when they remove a reward.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRewardRemoveEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToRewardRemoveEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRewardRemoveSubscription_1.EventSubChannelRewardRemoveSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a specific Channel Points reward being removed.
     *
     * @param user The user for which to get notifications for when they remove the reward.
     * @param rewardId The ID of the reward to get notifications for when it is removed.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRewardRemoveEventsForReward(user, rewardId, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToRewardRemoveEventsForReward: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRewardRemoveSubscription_1.EventSubChannelRewardRemoveSubscription, handler, this, userId, rewardId);
    }
    /**
     * Subscribes to events that represents a Channel Points reward being redeemed.
     *
     * @param user The user for which to get notifications for when their rewards are redeemed.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRedemptionAddEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelRedemptionEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRedemptionAddSubscription_1.EventSubChannelRedemptionAddSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a specific Channel Points reward being redeemed.
     *
     * @param user The user for which to get notifications when their reward is redeemed.
     * @param rewardId The ID of the reward for which to get notifications when it is redeemed.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRedemptionAddEventsForReward(user, rewardId, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToRedemptionAddEventsForReward: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRedemptionAddSubscription_1.EventSubChannelRedemptionAddSubscription, handler, this, userId, rewardId);
    }
    /**
     * Subscribes to events that represent a Channel Points reward being updated by a broadcaster.
     *
     * @param user The user for which to get notifications for when they update a reward.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRedemptionUpdateEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelRedemptionUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRedemptionUpdateSubscription_1.EventSubChannelRedemptionUpdateSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a specific Channel Points reward being updated by a broadcaster.
     *
     * @param user The user for which to get notifications for when they update the reward.
     * @param rewardId The ID of the reward for which to get notifications when it gets updated.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelRedemptionUpdateEventsForReward(user, rewardId, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelRedemptionUpdateEventsForReward: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelRedemptionUpdateSubscription_1.EventSubChannelRedemptionUpdateSubscription, handler, this, userId, rewardId);
    }
    /**
     * Subscribes to events that represent a Hype Train beginning.
     *
     * @param user The user for which to get notifications about Hype Trains in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelHypeTrainBeginEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelHypeTrainBeginEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelHypeTrainBeginSubscription_1.EventSubChannelHypeTrainBeginSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent progress in a Hype Train in a channel.
     *
     * @param user The user for which to get notifications about Hype Trains in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelHypeTrainProgressEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelHypeTrainProgressEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelHypeTrainProgressSubscription_1.EventSubChannelHypeTrainProgressSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent the end of a Hype Train in a channel.
     *
     * @param user The user for which to get notifications about Hype Trains in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToChannelHypeTrainEndEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToChannelHypeTrainEndEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubChannelHypeTrainEndSubscription_1.EventSubChannelHypeTrainEndSubscription, handler, this, userId);
    }
    /**
     * Subscribes to events that represent a user revoking authorization from an application.
     *
     * @param clientId The Client ID for which to get notifications about authorization revocations.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToUserAuthorizationRevokeEvents(clientId, handler) {
        return await this._genericSubscribe(EventSubUserAuthorizationRevokeSubscription_1.EventSubUserAuthorizationRevokeSubscription, handler, this, clientId);
    }
    /**
     * Subscribes to events that represent a user updating their account details.
     *
     * @param user The user for which to get notifications about account updates.
     * @param handler The function that will be called for any new notifications.
     */
    async subscribeToUserUpdateEvents(user, handler) {
        const userId = common_1.extractUserId(user);
        if (!numberRegex.test(userId)) {
            this._logger.warn('EventSubListener#subscribeToUserUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
        }
        return await this._genericSubscribe(EventSubUserUpdateSubscription_1.EventSubUserUpdateSubscription, handler, this, userId);
    }
    /** @private */
    async _buildHookUrl(id) {
        var _a;
        const hostName = await this._adapter.getHostName();
        // trim slashes on both ends
        const pathPrefix = (_a = this._adapter.pathPrefix) === null || _a === void 0 ? void 0 : _a.replace(/^\/|\/$/, '');
        return `https://${hostName}${pathPrefix ? '/' : ''}${pathPrefix !== null && pathPrefix !== void 0 ? pathPrefix : ''}/${id}`;
    }
    /** @private */
    _dropSubscription(id) {
        this._subscriptions.delete(id);
    }
    /** @private */
    _dropTwitchSubscription(id) {
        this._twitchSubscriptions.delete(id);
    }
    /** @private */
    _registerTwitchSubscription(id, data) {
        this._twitchSubscriptions.set(id, data);
    }
    async _genericSubscribe(clazz, handler, client, ...params) {
        const subscription = new clazz(handler, client, ...params);
        if (this._currentListenerPort) {
            await subscription.start(this._twitchSubscriptions.get(subscription.id));
        }
        this._subscriptions.set(subscription.id, subscription);
        return subscription;
    }
    _createHandleRequest() {
        return async (req, res, next) => {
            const { id } = req.param;
            const subscription = this._subscriptions.get(id);
            const twitchSubscription = this._twitchSubscriptions.get(id);
            const type = req.headers['twitch-eventsub-message-type'];
            if (subscription) {
                const messageId = req.headers['twitch-eventsub-message-id'];
                const timestamp = req.headers['twitch-eventsub-message-timestamp'];
                const body = await raw_body_1.default(req, true);
                const algoAndSignature = req.headers['twitch-eventsub-message-signature'];
                if (algoAndSignature === undefined) {
                    this._logger.warn(`Dropping unsigned message for action ${type} of event: ${id}`);
                    res.writeHead(410);
                    res.end();
                }
                else {
                    const verified = subscription._verifyData(messageId, timestamp, body, algoAndSignature);
                    if (verified) {
                        const data = JSON.parse(body);
                        if (type === 'webhook_callback_verification') {
                            const verificationBody = data;
                            subscription._verify();
                            if (twitchSubscription) {
                                twitchSubscription._status = 'enabled';
                            }
                            res.setHeader('Content-Length', verificationBody.challenge.length);
                            res.writeHead(200, undefined);
                            res.end(verificationBody.challenge);
                            this._logger.debug(`Successfully subscribed to event: ${id}`);
                        }
                        else if (type === 'notification') {
                            subscription._handleData(data.event);
                            res.writeHead(202);
                            res.end();
                        }
                        else {
                            this._logger.warn(`Unknown action ${type} for event: ${id}`);
                            res.writeHead(400);
                            res.end();
                        }
                    }
                    else {
                        this._logger.warn(`Could not verify action ${type} of event: ${id}`);
                        res.writeHead(410);
                        res.end();
                    }
                }
            }
            else {
                this._logger.warn(`Action ${type} of unknown event attempted: ${id}`);
                res.writeHead(410);
                res.end();
            }
            next();
        };
    }
};
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], EventSubListener.prototype, "_server", void 0);
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], EventSubListener.prototype, "_subscriptions", void 0);
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], EventSubListener.prototype, "_twitchSubscriptions", void 0);
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], EventSubListener.prototype, "_apiClient", void 0);
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], EventSubListener.prototype, "_secret", void 0);
EventSubListener = tslib_1.__decorate([
    common_1.rtfm('eventsub', 'EventSubListener')
], EventSubListener);
exports.EventSubListener = EventSubListener;
