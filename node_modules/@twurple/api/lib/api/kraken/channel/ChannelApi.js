"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelApi = void 0;
const tslib_1 = require("tslib");
const api_call_1 = require("@twurple/api-call");
const common_1 = require("@twurple/common");
const NoSubscriptionProgramError_1 = require("../../../Errors/NoSubscriptionProgramError");
const BaseApi_1 = require("../../BaseApi");
const Team_1 = require("../team/Team");
const User_1 = require("../user/User");
const Channel_1 = require("./Channel");
const ChannelFollow_1 = require("./ChannelFollow");
const ChannelSubscription_1 = require("./ChannelSubscription");
const PrivilegedChannel_1 = require("./PrivilegedChannel");
/**
 * The API methods that deal with channels.
 *
 * Can be accessed using `client.kraken.channels` on an {@ApiClient} instance.
 *
 * ## Example
 * ```ts
 * const api = new ApiClient(new StaticAuthProvider(clientId, accessToken));
 * const channel = await api.kraken.channels.getMyChannel();
 * ```
 */
let ChannelApi = class ChannelApi extends BaseApi_1.BaseApi {
    /**
     * Gets the channel the client is logged in to.
     */
    async getMyChannel() {
        return new PrivilegedChannel_1.PrivilegedChannel(await this._client.callApi({ url: 'channel', scope: 'channel_read' }), this._client);
    }
    /**
     * Retrieves the channel for the given user.
     *
     * @param user The user you want to retrieve the channel for.
     */
    async getChannel(user) {
        return new Channel_1.Channel(await this._client.callApi({ url: `channels/${common_1.extractUserId(user)}` }), this._client);
    }
    /**
     * Updates the given channel with the given data.
     *
     * @param channel The channel you want to update.
     * @param data The updated channel data.
     */
    async updateChannel(channel, data) {
        const channelId = common_1.extractUserId(channel);
        await this._client.callApi({
            url: `channels/${channelId}`,
            method: 'PUT',
            jsonBody: { channel: data },
            scope: 'channel_editor'
        });
    }
    /**
     * Retrieves the list of users that have editor rights to the given channel.
     *
     * @param channel The channel you want to retrieve the list of editors for.
     */
    async getChannelEditors(channel) {
        const channelId = common_1.extractUserId(channel);
        const data = await this._client.callApi({
            url: `channels/${channelId}/editors`,
            scope: 'channel_read'
        });
        return data.users.map(userData => new User_1.User(userData, this._client));
    }
    /**
     * Retrieves the list of followers of the given channel.
     *
     * @param channel The channel you want to retrieve the list of followers of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    async getChannelFollowers(channel, page, limit = 25, orderDirection) {
        const channelId = common_1.extractUserId(channel);
        const query = { limit: limit.toString() };
        if (page) {
            query.offset = ((page - 1) * limit).toString();
        }
        if (orderDirection) {
            query.direction = orderDirection;
        }
        const data = await this._client.callApi({
            url: `channels/${channelId}/follows`,
            query
        });
        return data.follows.map(followData => new ChannelFollow_1.ChannelFollow(followData, this._client));
    }
    /**
     * Retrieves the list of subscribers of the given channel.
     *
     * @param channel The channel you want to retrieve the list of subscribers of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    async getChannelSubscriptions(channel, page, limit = 25, orderDirection) {
        const data = await this._getChannelSubscriptions(channel, page, limit, orderDirection);
        return data.subscriptions.map(sub => new ChannelSubscription_1.ChannelSubscription(sub, this._client));
    }
    /**
     * Retrieves the total number of subscribers for the given channel.
     *
     * @param channel The channel you want to retrieve the number of subscribers for.
     */
    async getChannelSubscriptionCount(channel) {
        const data = await this._getChannelSubscriptions(channel, 0, 1);
        return data._total;
    }
    /**
     * Retrieves the subscription data for the given user to a given channel.
     *
     * Throws if the channel doesn't have a subscription program or the user is not subscribed to it.
     *
     * This method requires access to the channel. If you only have access to the user,
     * use {@UserApi#getSubscriptionData} instead.
     *
     * @param channel The channel to check the subscription to.
     * @param byUser The user to check the subscription for.
     */
    async getChannelSubscriptionByUser(channel, byUser) {
        const channelId = common_1.extractUserId(channel);
        const userId = common_1.extractUserId(byUser);
        try {
            return new ChannelSubscription_1.ChannelSubscription(await this._client.callApi({
                url: `channels/${channelId}/subscriptions/${userId}`,
                scope: 'channel_check_subscription'
            }), this._client);
        }
        catch (e) {
            if (e instanceof api_call_1.HttpStatusCodeError) {
                if (e.statusCode === 404) {
                    return null;
                }
                else if (e.statusCode === 422) {
                    throw new NoSubscriptionProgramError_1.NoSubscriptionProgramError(channelId);
                }
            }
            throw e;
        }
    }
    /**
     * Retrieves a list of teams of the given channel.
     *
     * @param channel The channel you want to retrieve the list of teams of.
     */
    async getChannelTeams(channel) {
        const channelId = common_1.extractUserId(channel);
        const data = await this._client.callApi({
            url: `channels/${channelId}/teams`,
            method: 'GET'
        });
        return data.teams.map(teamData => new Team_1.Team(teamData, this._client));
    }
    /**
     * Starts a commercial in the given channel.
     *
     * @param channel The channel to start the commercial in.
     * @param length The length of the commercial.
     */
    async startChannelCommercial(channel, length) {
        const channelId = common_1.extractUserId(channel);
        await this._client.callApi({
            url: `channels/${channelId}/commercial`,
            method: 'POST',
            jsonBody: { length },
            scope: 'channel_commercial'
        });
    }
    /**
     * Resets the given channel's stream key.
     *
     * @param channel The channel to reset the stream key for.
     */
    async resetChannelStreamKey(channel) {
        const channelId = common_1.extractUserId(channel);
        const channelData = await this._client.callApi({
            url: `channels/${channelId}/stream_key`,
            method: 'DELETE',
            scope: 'channel_stream'
        });
        return new PrivilegedChannel_1.PrivilegedChannel(channelData, this._client);
    }
    async _getChannelSubscriptions(channel, page, limit = 25, orderDirection) {
        const channelId = common_1.extractUserId(channel);
        const query = { limit: limit.toString() };
        if (page) {
            query.offset = ((page - 1) * limit).toString();
        }
        if (orderDirection) {
            query.direction = orderDirection;
        }
        try {
            return await this._client.callApi({
                url: `channels/${channelId}/subscriptions`,
                query,
                scope: 'channel_subscriptions'
            });
        }
        catch (e) {
            if (e instanceof api_call_1.HttpStatusCodeError && e.statusCode === 422) {
                throw new NoSubscriptionProgramError_1.NoSubscriptionProgramError(channelId);
            }
            throw e;
        }
    }
};
ChannelApi = tslib_1.__decorate([
    common_1.rtfm('api', 'ChannelApi')
], ChannelApi);
exports.ChannelApi = ChannelApi;
