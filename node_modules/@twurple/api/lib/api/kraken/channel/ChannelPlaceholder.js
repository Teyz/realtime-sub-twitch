"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelPlaceholder = void 0;
const tslib_1 = require("tslib");
const shared_utils_1 = require("@d-fischer/shared-utils");
const common_1 = require("@twurple/common");
const NoSubscriptionProgramError_1 = require("../../../Errors/NoSubscriptionProgramError");
/**
 * A placeholder for a channel.
 *
 * This is used for example when you only have retrieved user data, but not channel data.
 * This can do anything you can do with only a channel ID, as it's equivalent to the user ID.
 */
let ChannelPlaceholder = class ChannelPlaceholder {
    /** @private */
    constructor(id, client) {
        this._data = { _id: id };
        this._client = client;
    }
    /** @private */
    get cacheKey() {
        return this._data._id;
    }
    /**
     * The ID of the channel.
     */
    get id() {
        return this._data._id;
    }
    /**
     * Retrieves the list of cheermotes you can use in the channel.
     */
    async getCheermotes() {
        return await this._client.kraken.bits.getCheermotes(this);
    }
    /**
     * Retrieves the channel data.
     */
    async getChannel() {
        return await this._client.kraken.channels.getChannel(this);
    }
    /**
     * Retrieves the channel's stream data.
     */
    async getStream() {
        return await this._client.kraken.streams.getStreamByChannel(this);
    }
    /**
     * Retrieves the channel's followers.
     */
    async getFollowers() {
        return await this._client.kraken.channels.getChannelFollowers(this);
    }
    /**
     * Retrieves the channel's subscribers.
     */
    async getSubscriptions() {
        return await this._client.kraken.channels.getChannelSubscriptions(this);
    }
    /**
     * Retrieves the subscription data for the given user to the channel.
     *
     * Throws if the channel doesn't have a subscription program or the user is not subscribed to it.
     *
     * This method requires access to the channel. If you only have access to the user,
     * use {@User#getSubscriptionTo} instead.
     *
     * @param user The user you want to get the subscription data for.
     */
    async getSubscriptionBy(user) {
        return await this._client.kraken.channels.getChannelSubscriptionByUser(this, user);
    }
    /**
     * Checks whether the given user is subscribed to the channel.
     *
     * @param user The user you want to check the subscription for.
     */
    async hasSubscriber(user) {
        try {
            return (await this.getSubscriptionBy(user)) !== null;
        }
        catch (e) {
            if (e instanceof NoSubscriptionProgramError_1.NoSubscriptionProgramError) {
                return false;
            }
            throw e;
        }
    }
};
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], ChannelPlaceholder.prototype, "_data", void 0);
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], ChannelPlaceholder.prototype, "_client", void 0);
ChannelPlaceholder = tslib_1.__decorate([
    common_1.rtfm('api', 'ChannelPlaceholder', 'id')
], ChannelPlaceholder);
exports.ChannelPlaceholder = ChannelPlaceholder;
