"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.User = void 0;
const tslib_1 = require("tslib");
const shared_utils_1 = require("@d-fischer/shared-utils");
const common_1 = require("@twurple/common");
const NoSubscriptionProgramError_1 = require("../../../Errors/NoSubscriptionProgramError");
const ChannelPlaceholder_1 = require("../channel/ChannelPlaceholder");
/**
 * A Twitch user.
 */
let User = class User {
    /** @private */
    constructor(data, client) {
        this._data = data;
        this._client = client;
    }
    /** @private */
    get cacheKey() {
        return this._data._id;
    }
    /**
     * The ID of the user.
     */
    get id() {
        return this._data._id;
    }
    /**
     * The bio of the user.
     */
    get bio() {
        return this._data.bio;
    }
    /**
     * The date when the user was created, i.e. when they registered on Twitch.
     */
    get creationDate() {
        return new Date(this._data.created_at);
    }
    /**
     * The last date when the user changed anything in their profile, e.g. their description or their profile picture.
     */
    get updateDate() {
        return new Date(this._data.updated_at);
    }
    /**
     * The name of the user.
     */
    get name() {
        return this._data.name;
    }
    /**
     * The display name of the user.
     */
    get displayName() {
        return this._data.display_name;
    }
    /**
     * The URL to the profile picture of the user.
     */
    get logoUrl() {
        return this._data.logo;
    }
    /**
     * The type of the user.
     */
    get type() {
        return this._data.type;
    }
    /**
     * Retrieves the channel data of the user.
     */
    async getChannel() {
        return await this._client.kraken.channels.getChannel(this);
    }
    /**
     * Gets a channel placeholder object for the user, which can do anything you can do to a channel with just the ID.
     */
    getChannelPlaceholder() {
        return new ChannelPlaceholder_1.ChannelPlaceholder(this._data._id, this._client);
    }
    /**
     * Retrieves the currently running stream of the user.
     */
    async getStream() {
        return await this.getChannelPlaceholder().getStream();
    }
    /**
     * Retrieves the subscription data for the user to the given channel.
     *
     * Throws if the channel doesn't have a subscription program or the user is not subscribed to it.
     *
     * This method requires access to the user. If you only have access to the channel,
     * use {@ChannelPlaceholder#getSubscriptionBy} instead.
     *
     * @param channel The channel you want to get the subscription data for.
     */
    async getSubscriptionTo(channel) {
        return await this._client.kraken.users.getSubscriptionData(this, channel);
    }
    /**
     * Checks whether the user is subscribed to the given channel.
     *
     * @param channel The channel you want to check the subscription for.
     */
    async isSubscribedTo(channel) {
        try {
            return (await this.getSubscriptionTo(channel)) !== null;
        }
        catch (e) {
            if (e instanceof NoSubscriptionProgramError_1.NoSubscriptionProgramError) {
                return false;
            }
            throw e;
        }
    }
    /**
     * Retrieves a list of channels followed by the user.
     *
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderBy The field to order by.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    async getFollows(page, limit, orderBy, orderDirection) {
        return await this._client.kraken.users.getFollowedChannels(this, page, limit, orderBy, orderDirection);
    }
    /**
     * Retrieves the follow data of the user to a given channel.
     *
     * @param channel The channel to retrieve the follow data for.
     */
    async getFollowTo(channel) {
        return await this._client.kraken.users.getFollowedChannel(this, channel);
    }
    /**
     * Checks whether the user is following the given channel.
     *
     * @param channel The channel to check for the user's follow.
     */
    async follows(channel) {
        try {
            return (await this.getFollowTo(channel)) !== null;
        }
        catch (e) {
            throw e;
        }
    }
    /**
     * Follows the channel with the authenticated user.
     */
    async follow() {
        const currentUser = await this._client.kraken.users.getMe();
        return await currentUser.followChannel(this);
    }
    /**
     * Unfollows the channel with the authenticated user.
     */
    async unfollow() {
        const currentUser = await this._client.kraken.users.getMe();
        await currentUser.unfollowChannel(this);
    }
    /**
     * Retrieves the emotes the user can use.
     */
    async getEmotes() {
        return await this._client.kraken.users.getUserEmotes(this);
    }
};
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], User.prototype, "_data", void 0);
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], User.prototype, "_client", void 0);
User = tslib_1.__decorate([
    common_1.rtfm('api', 'User', 'id')
], User);
exports.User = User;
