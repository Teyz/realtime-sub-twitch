"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserApi = void 0;
const tslib_1 = require("tslib");
const shared_utils_1 = require("@d-fischer/shared-utils");
const api_call_1 = require("@twurple/api-call");
const common_1 = require("@twurple/common");
const NoSubscriptionProgramError_1 = require("../../../Errors/NoSubscriptionProgramError");
const BaseApi_1 = require("../../BaseApi");
const EmoteSetList_1 = require("../channel/EmoteSetList");
const PrivilegedUser_1 = require("./PrivilegedUser");
const User_1 = require("./User");
const UserBlock_1 = require("./UserBlock");
const UserChatInfo_1 = require("./UserChatInfo");
const UserFollow_1 = require("./UserFollow");
const UserSubscription_1 = require("./UserSubscription");
/**
 * The API methods that deal with users.
 *
 * Can be accessed using `client.kraken.users` on an {@ApiClient} instance.
 *
 * ## Example
 * ```ts
 * const api = new ApiClient(new StaticAuthProvider(clientId, accessToken));
 * const user = await api.kraken.users.getUser('125328655');
 * ```
 */
let UserApi = class UserApi extends BaseApi_1.BaseApi {
    /**
     * Retrieves the user data of the currently authenticated user.
     */
    async getMe() {
        return new PrivilegedUser_1.PrivilegedUser(await this._client.callApi({ url: 'user', scope: 'user_read' }), this._client);
    }
    /**
     * Retrieves the user data for the given user ID.
     *
     * @param userId The user ID you want to look up.
     */
    async getUser(userId) {
        const userData = await this._client.callApi({ url: `users/${common_1.extractUserId(userId)}` });
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!userData) {
            throw new common_1.HellFreezesOverError('Could not get authenticated user');
        }
        return new User_1.User(userData, this._client);
    }
    /**
     * Retrieves the user data for the given user name.
     *
     * @param userName The user name you want to look up.
     */
    async getUserByName(userName) {
        const { users } = await this._client.callApi({
            url: 'users',
            query: { login: userName }
        });
        if (users.length === 0) {
            return null;
        }
        return new User_1.User(users[0], this._client);
    }
    /**
     * Retrieves the user data for the given user names.
     *
     * @param userNames The user names you want to look up.
     */
    async getUsersByNames(userNames) {
        userNames = userNames.map(name => name.toLowerCase());
        const usersData = await this._client.callApi({
            url: 'users',
            query: { login: userNames.join(',') }
        });
        const usersArr = usersData.users.map(data => new User_1.User(data, this._client));
        const users = shared_utils_1.indexBy(usersArr, 'name');
        return { ...users };
    }
    /**
     * Retrieves information about the user's chat appearance and privileges.
     *
     * @param user The user you want to get chat info for.
     */
    async getChatInfo(user) {
        const userId = common_1.extractUserId(user);
        const data = await this._client.callApi({ url: `users/${userId}/chat` });
        return new UserChatInfo_1.UserChatInfo(data, this._client);
    }
    /**
     * Retrieves the emotes a given user can use.
     *
     * @param user The user you want to get emotes for.
     */
    async getUserEmotes(user) {
        const userId = common_1.extractUserId(user);
        const data = await this._client.callApi({
            url: `users/${userId}/emotes`,
            scope: 'user_subscriptions'
        });
        return new EmoteSetList_1.EmoteSetList(data.emoticon_sets);
    }
    /**
     * Retrieves the subscription data for a given user to a given channel.
     *
     * @param user The user to retrieve the subscription data of.
     * @param toChannel The channel you want to retrieve the subscription data to.
     */
    async getSubscriptionData(user, toChannel) {
        const userId = common_1.extractUserId(user);
        const channelId = common_1.extractUserId(toChannel);
        try {
            return new UserSubscription_1.UserSubscription(await this._client.callApi({
                url: `users/${userId}/subscriptions/${channelId}`,
                scope: 'user_subscriptions'
            }), this._client);
        }
        catch (e) {
            if (e instanceof api_call_1.HttpStatusCodeError) {
                if (e.statusCode === 404) {
                    return null;
                }
                else if (e.statusCode === 422) {
                    throw new NoSubscriptionProgramError_1.NoSubscriptionProgramError(channelId);
                }
            }
            throw e;
        }
    }
    /**
     * Get a list of channels a given user follows.
     *
     * @param user The user you want to retrieve the follows of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderBy The field to order by.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    async getFollowedChannels(user, page, limit = 25, orderBy, orderDirection) {
        const userId = common_1.extractUserId(user);
        const query = {};
        if (page) {
            query.offset = ((page - 1) * limit).toString();
        }
        query.limit = limit.toString();
        if (orderBy) {
            query.sortby = orderBy;
        }
        if (orderDirection) {
            query.direction = orderDirection;
        }
        const data = await this._client.callApi({
            url: `users/${userId}/follows/channels`,
            query
        });
        return data.follows.map(follow => new UserFollow_1.UserFollow(follow, this._client));
    }
    /**
     * Get follow data for a given user to a given channel.
     *
     * @param user The user you want to retrieve follow data of.
     * @param channel The channel you want to retrieve follow data to.
     */
    async getFollowedChannel(user, channel) {
        const userId = common_1.extractUserId(user);
        const channelId = common_1.extractUserId(channel);
        try {
            const data = await this._client.callApi({
                url: `users/${userId}/follows/channels/${channelId}`
            });
            return new UserFollow_1.UserFollow(data, this._client);
        }
        catch (e) {
            if (e instanceof api_call_1.HttpStatusCodeError) {
                if (e.statusCode === 404) {
                    return null;
                }
            }
            throw e;
        }
    }
    /**
     * Follows a given channel with a given user.
     *
     * @param user The user you want to follow with.
     * @param channel The channel to follow.
     * @param notifications Whether the user will receive notifications.
     */
    async followChannel(user, channel, notifications) {
        const userId = common_1.extractUserId(user);
        const channelId = common_1.extractUserId(channel);
        const data = await this._client.callApi({
            url: `users/${userId}/follows/channels/${channelId}`,
            method: 'PUT',
            scope: 'user_follows_edit',
            jsonBody: { notifications }
        });
        return new UserFollow_1.UserFollow(data, this._client);
    }
    /**
     * Unfollows a given channel with a given user.
     *
     * @param user The user you want to unfollow with.
     * @param channel The channel to unfollow.
     */
    async unfollowChannel(user, channel) {
        const userId = common_1.extractUserId(user);
        const channelId = common_1.extractUserId(channel);
        await this._client.callApi({
            url: `users/${userId}/follows/channels/${channelId}`,
            scope: 'user_follows_edit',
            method: 'DELETE'
        });
    }
    /**
     * Retrieves a list of users a given user has blocked.
     *
     * @param user The user you want to retrieve the block list of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    async getBlockedUsers(user, page, limit = 25) {
        const userId = common_1.extractUserId(user);
        const query = { limit: limit.toString() };
        if (page) {
            query.offset = ((page - 1) * limit).toString();
        }
        const data = await this._client.callApi({
            url: `users/${userId}/blocks`,
            query,
            scope: 'user_blocks_read'
        });
        return data.blocks.map(block => new UserBlock_1.UserBlock(block, this._client));
    }
    /**
     * Blocks a given user with another given user.
     *
     * @param user The user you want to block with.
     * @param userToBlock The user to block.
     */
    async blockUser(user, userToBlock) {
        const userId = common_1.extractUserId(user);
        const userIdToBlock = common_1.extractUserId(userToBlock);
        const data = await this._client.callApi({
            url: `users/${userId}/blocks/${userIdToBlock}`,
            method: 'PUT',
            scope: 'user_blocks_edit'
        });
        return new UserBlock_1.UserBlock(data, this._client);
    }
    /**
     * Unblocks a given user with another given user.
     *
     * @param user The user you want to unblock with.
     * @param userToUnblock The user to unblock.
     */
    async unblockUser(user, userToUnblock) {
        const userId = common_1.extractUserId(user);
        const userIdToUnblock = common_1.extractUserId(userToUnblock);
        await this._client.callApi({
            url: `users/${userId}/blocks/${userIdToUnblock}`,
            method: 'DELETE',
            scope: 'user_blocks_edit'
        });
    }
};
UserApi = tslib_1.__decorate([
    common_1.rtfm('api', 'UserApi')
], UserApi);
exports.UserApi = UserApi;
