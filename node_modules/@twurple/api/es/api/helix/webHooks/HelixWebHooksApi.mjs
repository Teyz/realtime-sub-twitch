import { __decorate } from "tslib";
import { extractUserId, rtfm } from '@twurple/common';
import { BaseApi } from "../../BaseApi.mjs";
import { HelixPaginatedRequestWithTotal } from "../HelixPaginatedRequestWithTotal.mjs";
import { createPaginatedResultWithTotal } from "../HelixPaginatedResult.mjs";
import { makePaginationQuery } from "../HelixPagination.mjs";
import { HelixWebHookSubscription } from "./HelixWebHookSubscription.mjs";
/**
 * The API methods that deal with WebHooks.
 *
 * Can be accessed using `client.helix.webHooks` on an {@ApiClient} instance.
 *
 * ## Before using these methods...
 *
 * All of the methods in this class assume that you are already running a working WebHook listener at the given callback URL.
 *
 * If you don't already have one, we recommend use of the `@twurple/webhooks` library, which handles subscribing and unsubscribing to these topics automatically.
 *
 * ## Example
 * ```ts
 * const api = new ApiClient(new StaticAuthProvider(clientId, accessToken));
 * await api.helix.webHooks.subscribeToUserFollowsTo('125328655', { callbackUrl: 'https://example.com' });
 * ```
 */
let HelixWebHooksApi = class HelixWebHooksApi extends BaseApi {
    /**
     * Retrieves the current WebHook subscriptions for the current client.
     *
     * Requires an app access token to work; does not work with user tokens.
     */
    async getSubscriptions(pagination) {
        const result = await this._client.callApi({
            type: 'helix',
            url: 'webhooks/subscriptions',
            query: makePaginationQuery(pagination)
        });
        return createPaginatedResultWithTotal(result, HelixWebHookSubscription, this._client);
    }
    /**
     * Creates a paginator for the current WebHook subscriptions for the current client.
     *
     * Requires an app access token to work; does not work with user tokens.
     */
    getSubscriptionsPaginated() {
        return new HelixPaginatedRequestWithTotal({
            url: 'webhooks/subscriptions'
        }, this._client, data => new HelixWebHookSubscription(data, this._client));
    }
    /**
     * Sends an arbitrary request to subscribe to or unsubscribe from an event.
     *
     * @expandParams
     */
    async sendHubRequest(options) {
        const { mode, callbackUrl, topicUrl, validityInSeconds = 3600, secret, scope } = options;
        await this._client.callApi({
            url: 'webhooks/hub',
            type: 'helix',
            method: 'POST',
            scope,
            jsonBody: {
                'hub.mode': mode,
                'hub.topic': topicUrl,
                'hub.callback': callbackUrl,
                'hub.lease_seconds': mode === 'subscribe' ? validityInSeconds.toString() : undefined,
                'hub.secret': secret
            }
        });
    }
    /**
     * Subscribes to events representing a user following other users.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about the users they will follow.
     * @param options
     */
    async subscribeToUserFollowsFrom(user, options) {
        await this._sendUserFollowsHubRequest('subscribe', 'from', user, options);
    }
    /**
     * Subscribes to events representing a user being followed by other users.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about the users they will be followed by.
     * @param options
     */
    async subscribeToUserFollowsTo(user, options) {
        await this._sendUserFollowsHubRequest('subscribe', 'to', user, options);
    }
    /**
     * Unsubscribes from events representing a user following other users.
     *
     * @expandParams
     *
     * @param user The user for which to not get any more notifications about the users they will follow.
     * @param options
     */
    async unsubscribeFromUserFollowsFrom(user, options) {
        await this._sendUserFollowsHubRequest('unsubscribe', 'from', user, options);
    }
    /**
     * Subscribes to events representing a Hype Train progressing.
     *
     * @expandParams
     *
     * @param broadcasterId The broadcaster / channel for which to get notifications about Hype Train events.
     * @param options
     */
    async subscribeToHypeTrainEvents(broadcasterId, options) {
        await this._sendHypeTrainEventHubRequest('subscribe', broadcasterId, options);
    }
    /**
     * Unsubscribes from events representing a Hype Train progressing.
     *
     * @expandParams
     *
     * @param broadcasterId The broadcaster / channel for which to get notifications about Hype Train events.
     * @param options
     */
    async unsubscribeFromHypeTrainEvents(broadcasterId, options) {
        await this._sendHypeTrainEventHubRequest('unsubscribe', broadcasterId, options);
    }
    /**
     * Unsubscribes from events representing a user being followed by other users.
     *
     * @expandParams
     *
     * @param user The user for which to not get any more notifications about the users they will be followed by.
     * @param options
     */
    async unsubscribeFromUserFollowsTo(user, options) {
        await this._sendUserFollowsHubRequest('unsubscribe', 'to', user, options);
    }
    /**
     * Subscribes to events representing a stream changing, i.e. going live, offline or changing its title or category.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about their streams changing.
     * @param options
     */
    async subscribeToStreamChanges(user, options) {
        await this._sendStreamChangeHubRequest('subscribe', user, options);
    }
    /**
     * Unsubscribes from events representing a stream changing.
     *
     * @expandParams
     *
     * @param user The user for which not to get any more notifications about their streams changing.
     * @param options
     */
    async unsubscribeFromStreamChanges(user, options) {
        await this._sendStreamChangeHubRequest('unsubscribe', user, options);
    }
    /**
     * Subscribes to events representing a user changing a public setting or their email address.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about changing a setting.
     * @param options
     * @param withEmail Whether to subscribe to email address changes. This adds the necessary scope to read the email address to the request.
     */
    async subscribeToUserChanges(user, options, withEmail = false) {
        await this._sendUserChangeHubRequest('subscribe', user, options, withEmail);
    }
    /**
     * Unsubscribes from events representing a user changing a public setting or their email address.
     *
     * @expandParams
     *
     * @param user The user for which not to get any more notifications about changing a setting.
     * @param options
     */
    async unsubscribeFromUserChanges(user, options) {
        await this._sendUserChangeHubRequest('unsubscribe', user, options);
    }
    /**
     * Subscribes to events representing the start or end of a channel subscription.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about subscriptions to their channel.
     * @param options
     */
    async subscribeToSubscriptionEvents(user, options) {
        await this._sendSubscriptionEventsHubRequest('subscribe', user, options);
    }
    /**
     * Unsubscribes from events representing the start or end of a channel subscription.
     *
     * @expandParams
     *
     * @param user The user for which not to get any more notifications about subscriptions and unsubscriptions to their channel.
     * @param options
     */
    async unsubscribeFromSubscriptionEvents(user, options) {
        await this._sendSubscriptionEventsHubRequest('unsubscribe', user, options);
    }
    /**
     * Subscribes to extension transactions.
     *
     * @expandParams
     *
     * @param extensionId The extension ID for which to get notifications about transactions.
     * @param options
     */
    async subscribeToExtensionTransactions(extensionId, options) {
        await this._sendExtensionTransactionsHubRequest('subscribe', extensionId, options);
    }
    /**
     * Unsubscribes from extension transactions.
     *
     * @expandParams
     *
     * @param extensionId The extension ID for which not to get any more notifications about transactions.
     * @param options
     */
    async unsubscribeFromExtensionTransactions(extensionId, options) {
        await this._sendExtensionTransactionsHubRequest('unsubscribe', extensionId, options);
    }
    /**
     * Subscribes to events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about bans or unbans in their channel.
     * @param options
     */
    async subscribeToBanEvents(broadcaster, options) {
        await this._sendBanEventsHubRequest('subscribe', broadcaster, options);
    }
    /**
     * Unsubscribes from events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about bans or unbans in their channel.
     * @param options
     */
    async unsubscribeFromBanEvents(broadcaster, options) {
        await this._sendBanEventsHubRequest('unsubscribe', broadcaster, options);
    }
    /**
     * Subscribes to events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about bans or unbans in their channel.
     * @param user The user that is being banned or unbanned.
     * @param options
     */
    async subscribeToBanEventsForUser(broadcaster, user, options) {
        await this._sendBanEventsHubRequest('subscribe', broadcaster, options, user);
    }
    /**
     * Unsubscribes from events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about bans or unbans in their channel.
     * @param user The user that is being banned or unbanned.
     * @param options
     */
    async unsubscribeFromBanEventsForUser(broadcaster, user, options) {
        await this._sendBanEventsHubRequest('unsubscribe', broadcaster, options, user);
    }
    /**
     * Subscribes to events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about moderator changes in their channel.
     * @param options
     */
    async subscribeToModeratorEvents(broadcaster, options) {
        await this._sendModeratorEventsHubRequest('subscribe', broadcaster, options);
    }
    /**
     * Unsubscribes from events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about moderator changes in their channel.
     * @param options
     */
    async unsubscribeFromModeratorEvents(broadcaster, options) {
        await this._sendModeratorEventsHubRequest('unsubscribe', broadcaster, options);
    }
    /**
     * Subscribes to events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about moderator changes in their channel.
     * @param user The user that is being modded or unmodded.
     * @param options
     */
    async subscribeToModeratorEventsForUser(broadcaster, user, options) {
        await this._sendModeratorEventsHubRequest('subscribe', broadcaster, options, user);
    }
    /**
     * Unsubscribes from events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about moderator changes in their channel.
     * @param user The user that is being modded or unmodded.
     * @param options
     */
    async unsubscribeFromModeratorEventsForUser(broadcaster, user, options) {
        await this._sendModeratorEventsHubRequest('unsubscribe', broadcaster, options, user);
    }
    async _sendUserFollowsHubRequest(mode, direction, user, options) {
        const userId = extractUserId(user);
        await this.sendHubRequest({
            mode,
            topicUrl: `https://api.twitch.tv/helix/users/follows?first=1&${direction}_id=${userId}`,
            ...options
        });
    }
    async _sendHypeTrainEventHubRequest(mode, user, options) {
        const userId = extractUserId(user);
        await this.sendHubRequest({
            mode,
            topicUrl: `https://api.twitch.tv/helix/hypetrain/events?broadcaster_id=${userId}&first=1`,
            scope: 'channel:read:hype_train',
            ...options
        });
    }
    async _sendStreamChangeHubRequest(mode, user, options) {
        const userId = extractUserId(user);
        await this.sendHubRequest({
            mode,
            topicUrl: `https://api.twitch.tv/helix/streams?user_id=${userId}`,
            ...options
        });
    }
    async _sendUserChangeHubRequest(mode, user, options, withEmail = false) {
        const userId = extractUserId(user);
        await this.sendHubRequest({
            mode,
            topicUrl: `https://api.twitch.tv/helix/users?id=${userId}`,
            scope: withEmail ? 'user:read:email' : undefined,
            ...options
        });
    }
    async _sendSubscriptionEventsHubRequest(mode, user, options) {
        const userId = extractUserId(user);
        await this.sendHubRequest({
            mode,
            topicUrl: `https://api.twitch.tv/helix/subscriptions/events?broadcaster_id=${userId}&first=1`,
            scope: 'channel:read:subscriptions',
            ...options
        });
    }
    async _sendExtensionTransactionsHubRequest(mode, extensionId, options) {
        await this.sendHubRequest({
            mode,
            topicUrl: `https://api.twitch.tv/helix/extensions/transactions?extension_id=${extensionId}&first=1`,
            ...options
        });
    }
    async _sendBanEventsHubRequest(mode, broadcaster, options, user) {
        const broadcasterId = extractUserId(broadcaster);
        let topicUrl = `https://api.twitch.tv/helix/moderation/banned/events?broadcaster_id=${broadcasterId}&first=1`;
        if (user) {
            topicUrl += `&user_id=${extractUserId(user)}`;
        }
        await this.sendHubRequest({
            mode,
            topicUrl,
            scope: 'moderation:read',
            ...options
        });
    }
    async _sendModeratorEventsHubRequest(mode, broadcaster, options, user) {
        const broadcasterId = extractUserId(broadcaster);
        let topicUrl = `https://api.twitch.tv/helix/moderation/moderators/events?broadcaster_id=${broadcasterId}&first=1`;
        if (user) {
            topicUrl += `&user_id=${extractUserId(user)}`;
        }
        await this.sendHubRequest({
            mode,
            topicUrl,
            scope: 'moderation:read',
            ...options
        });
    }
};
HelixWebHooksApi = __decorate([
    rtfm('api', 'HelixWebHooksApi')
], HelixWebHooksApi);
export { HelixWebHooksApi };
