import { __decorate } from "tslib";
import { HttpStatusCodeError } from '@twurple/api-call';
import { extractUserId, rtfm } from '@twurple/common';
import { NoSubscriptionProgramError } from "../../../Errors/NoSubscriptionProgramError.mjs";
import { BaseApi } from "../../BaseApi.mjs";
import { Team } from "../team/Team.mjs";
import { User } from "../user/User.mjs";
import { Channel } from "./Channel.mjs";
import { ChannelFollow } from "./ChannelFollow.mjs";
import { ChannelSubscription } from "./ChannelSubscription.mjs";
import { PrivilegedChannel } from "./PrivilegedChannel.mjs";
/**
 * The API methods that deal with channels.
 *
 * Can be accessed using `client.kraken.channels` on an {@ApiClient} instance.
 *
 * ## Example
 * ```ts
 * const api = new ApiClient(new StaticAuthProvider(clientId, accessToken));
 * const channel = await api.kraken.channels.getMyChannel();
 * ```
 */
let ChannelApi = class ChannelApi extends BaseApi {
    /**
     * Gets the channel the client is logged in to.
     */
    async getMyChannel() {
        return new PrivilegedChannel(await this._client.callApi({ url: 'channel', scope: 'channel_read' }), this._client);
    }
    /**
     * Retrieves the channel for the given user.
     *
     * @param user The user you want to retrieve the channel for.
     */
    async getChannel(user) {
        return new Channel(await this._client.callApi({ url: `channels/${extractUserId(user)}` }), this._client);
    }
    /**
     * Updates the given channel with the given data.
     *
     * @param channel The channel you want to update.
     * @param data The updated channel data.
     */
    async updateChannel(channel, data) {
        const channelId = extractUserId(channel);
        await this._client.callApi({
            url: `channels/${channelId}`,
            method: 'PUT',
            jsonBody: { channel: data },
            scope: 'channel_editor'
        });
    }
    /**
     * Retrieves the list of users that have editor rights to the given channel.
     *
     * @param channel The channel you want to retrieve the list of editors for.
     */
    async getChannelEditors(channel) {
        const channelId = extractUserId(channel);
        const data = await this._client.callApi({
            url: `channels/${channelId}/editors`,
            scope: 'channel_read'
        });
        return data.users.map(userData => new User(userData, this._client));
    }
    /**
     * Retrieves the list of followers of the given channel.
     *
     * @param channel The channel you want to retrieve the list of followers of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    async getChannelFollowers(channel, page, limit = 25, orderDirection) {
        const channelId = extractUserId(channel);
        const query = { limit: limit.toString() };
        if (page) {
            query.offset = ((page - 1) * limit).toString();
        }
        if (orderDirection) {
            query.direction = orderDirection;
        }
        const data = await this._client.callApi({
            url: `channels/${channelId}/follows`,
            query
        });
        return data.follows.map(followData => new ChannelFollow(followData, this._client));
    }
    /**
     * Retrieves the list of subscribers of the given channel.
     *
     * @param channel The channel you want to retrieve the list of subscribers of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    async getChannelSubscriptions(channel, page, limit = 25, orderDirection) {
        const data = await this._getChannelSubscriptions(channel, page, limit, orderDirection);
        return data.subscriptions.map(sub => new ChannelSubscription(sub, this._client));
    }
    /**
     * Retrieves the total number of subscribers for the given channel.
     *
     * @param channel The channel you want to retrieve the number of subscribers for.
     */
    async getChannelSubscriptionCount(channel) {
        const data = await this._getChannelSubscriptions(channel, 0, 1);
        return data._total;
    }
    /**
     * Retrieves the subscription data for the given user to a given channel.
     *
     * Throws if the channel doesn't have a subscription program or the user is not subscribed to it.
     *
     * This method requires access to the channel. If you only have access to the user,
     * use {@UserApi#getSubscriptionData} instead.
     *
     * @param channel The channel to check the subscription to.
     * @param byUser The user to check the subscription for.
     */
    async getChannelSubscriptionByUser(channel, byUser) {
        const channelId = extractUserId(channel);
        const userId = extractUserId(byUser);
        try {
            return new ChannelSubscription(await this._client.callApi({
                url: `channels/${channelId}/subscriptions/${userId}`,
                scope: 'channel_check_subscription'
            }), this._client);
        }
        catch (e) {
            if (e instanceof HttpStatusCodeError) {
                if (e.statusCode === 404) {
                    return null;
                }
                else if (e.statusCode === 422) {
                    throw new NoSubscriptionProgramError(channelId);
                }
            }
            throw e;
        }
    }
    /**
     * Retrieves a list of teams of the given channel.
     *
     * @param channel The channel you want to retrieve the list of teams of.
     */
    async getChannelTeams(channel) {
        const channelId = extractUserId(channel);
        const data = await this._client.callApi({
            url: `channels/${channelId}/teams`,
            method: 'GET'
        });
        return data.teams.map(teamData => new Team(teamData, this._client));
    }
    /**
     * Starts a commercial in the given channel.
     *
     * @param channel The channel to start the commercial in.
     * @param length The length of the commercial.
     */
    async startChannelCommercial(channel, length) {
        const channelId = extractUserId(channel);
        await this._client.callApi({
            url: `channels/${channelId}/commercial`,
            method: 'POST',
            jsonBody: { length },
            scope: 'channel_commercial'
        });
    }
    /**
     * Resets the given channel's stream key.
     *
     * @param channel The channel to reset the stream key for.
     */
    async resetChannelStreamKey(channel) {
        const channelId = extractUserId(channel);
        const channelData = await this._client.callApi({
            url: `channels/${channelId}/stream_key`,
            method: 'DELETE',
            scope: 'channel_stream'
        });
        return new PrivilegedChannel(channelData, this._client);
    }
    async _getChannelSubscriptions(channel, page, limit = 25, orderDirection) {
        const channelId = extractUserId(channel);
        const query = { limit: limit.toString() };
        if (page) {
            query.offset = ((page - 1) * limit).toString();
        }
        if (orderDirection) {
            query.direction = orderDirection;
        }
        try {
            return await this._client.callApi({
                url: `channels/${channelId}/subscriptions`,
                query,
                scope: 'channel_subscriptions'
            });
        }
        catch (e) {
            if (e instanceof HttpStatusCodeError && e.statusCode === 422) {
                throw new NoSubscriptionProgramError(channelId);
            }
            throw e;
        }
    }
};
ChannelApi = __decorate([
    rtfm('api', 'ChannelApi')
], ChannelApi);
export { ChannelApi };
