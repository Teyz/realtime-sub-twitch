import { __decorate } from "tslib";
import { Cacheable, CachedGetter } from '@d-fischer/cache-decorators';
import { callTwitchApi, callTwitchApiRaw, HttpStatusCodeError, transformTwitchApiResponse } from '@twurple/api-call';
import { accessTokenIsExpired, InvalidTokenError, TokenInfo } from '@twurple/auth';
import { rtfm } from '@twurple/common';
import { BadgesApi } from "./api/badges/BadgesApi.mjs";
import { HelixApiGroup } from "./api/helix/HelixApiGroup.mjs";
import { HelixRateLimiter } from "./api/helix/HelixRateLimiter.mjs";
import { KrakenApiGroup } from "./api/kraken/KrakenApiGroup.mjs";
import { UnsupportedApi } from "./api/unsupported/UnsupportedApi.mjs";
import { ConfigError } from "./Errors/ConfigError.mjs";
/**
 * An API client for the Twitch Kraken and Helix APIs.
 */
let ApiClient = class ApiClient {
    /**
     * Creates a new API client instance.
     *
     * @param config Configuration for the client instance.
     */
    constructor(config) {
        if (!config.authProvider) {
            throw new ConfigError('No auth provider given. Please supply the `authProvider` option.');
        }
        this._helixRateLimiter = new HelixRateLimiter({ logger: config.logger });
        this._config = config;
    }
    /**
     * Requests scopes from the auth provider.
     *
     * @param scopes The scopes to request.
     */
    async requestScopes(scopes) {
        await this._config.authProvider.getAccessToken(scopes);
    }
    /**
     * Retrieves information about your access token.
     */
    async getTokenInfo() {
        try {
            const data = await this.callApi({ type: 'auth', url: 'validate' });
            return new TokenInfo(data);
        }
        catch (e) {
            if (e instanceof HttpStatusCodeError && e.statusCode === 401) {
                throw new InvalidTokenError();
            }
            throw e;
        }
    }
    /**
     * Makes a call to the Twitch API using your access token.
     *
     * @param options The configuration of the call.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async callApi(options) {
        var _a;
        const { authProvider } = this._config;
        const shouldAuth = (_a = options.auth) !== null && _a !== void 0 ? _a : true;
        let accessToken = shouldAuth
            ? await authProvider.getAccessToken(options.scope ? [options.scope] : undefined)
            : null;
        if (!accessToken) {
            return await callTwitchApi(options, authProvider.clientId, undefined, this._config.fetchOptions);
        }
        if (accessTokenIsExpired(accessToken) && authProvider.refresh) {
            const newAccessToken = await authProvider.refresh();
            if (newAccessToken) {
                accessToken = newAccessToken;
            }
        }
        let response = await this._callApiInternal(options, authProvider.clientId, accessToken.accessToken);
        if (response.status === 401 && authProvider.refresh) {
            await authProvider.refresh();
            accessToken = await authProvider.getAccessToken(options.scope ? [options.scope] : []);
            if (accessToken) {
                response = await this._callApiInternal(options, authProvider.clientId, accessToken.accessToken);
            }
        }
        return await transformTwitchApiResponse(response);
    }
    /**
     * A group of Kraken API methods.
     *
     * @deprecated Use Helix wherever possible.
     */
    get kraken() {
        return new KrakenApiGroup(this);
    }
    /**
     * A group of Helix API methods.
     */
    get helix() {
        return new HelixApiGroup(this);
    }
    /**
     * The API methods that deal with badges.
     */
    get badges() {
        return new BadgesApi(this);
    }
    /**
     * Various API methods that are not officially supported by Twitch.
     */
    get unsupported() {
        return new UnsupportedApi(this);
    }
    /** @private */
    get _authProvider() {
        return this._config.authProvider;
    }
    async _callApiInternal(options, clientId, accessToken) {
        const { fetchOptions } = this._config;
        if (options.type === 'helix') {
            return await this._helixRateLimiter.request({ options, clientId, accessToken, fetchOptions });
        }
        return await callTwitchApiRaw(options, clientId, accessToken, fetchOptions);
    }
};
__decorate([
    CachedGetter()
], ApiClient.prototype, "kraken", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "helix", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "badges", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "unsupported", null);
ApiClient = __decorate([
    Cacheable,
    rtfm('api', 'ApiClient')
], ApiClient);
export { ApiClient };
