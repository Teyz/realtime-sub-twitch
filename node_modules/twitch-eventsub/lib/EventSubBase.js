"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventSubBase = void 0;
var tslib_1 = require("tslib");
var logger_1 = require("@d-fischer/logger");
var raw_body_1 = require("@d-fischer/raw-body");
var shared_utils_1 = require("@d-fischer/shared-utils");
var twitch_auth_1 = require("twitch-auth");
var twitch_common_1 = require("twitch-common");
var EventSubChannelBanSubscription_1 = require("./Subscriptions/EventSubChannelBanSubscription");
var EventSubChannelCheerSubscription_1 = require("./Subscriptions/EventSubChannelCheerSubscription");
var EventSubChannelFollowSubscription_1 = require("./Subscriptions/EventSubChannelFollowSubscription");
var EventSubChannelHypeTrainBeginSubscription_1 = require("./Subscriptions/EventSubChannelHypeTrainBeginSubscription");
var EventSubChannelHypeTrainEndSubscription_1 = require("./Subscriptions/EventSubChannelHypeTrainEndSubscription");
var EventSubChannelHypeTrainProgressSubscription_1 = require("./Subscriptions/EventSubChannelHypeTrainProgressSubscription");
var EventSubChannelModeratorAddSubscription_1 = require("./Subscriptions/EventSubChannelModeratorAddSubscription");
var EventSubChannelModeratorRemoveSubscription_1 = require("./Subscriptions/EventSubChannelModeratorRemoveSubscription");
var EventSubChannelPollBeginSubscription_1 = require("./Subscriptions/EventSubChannelPollBeginSubscription");
var EventSubChannelPollEndSubscription_1 = require("./Subscriptions/EventSubChannelPollEndSubscription");
var EventSubChannelPollProgressSubscription_1 = require("./Subscriptions/EventSubChannelPollProgressSubscription");
var EventSubChannelPredictionBeginSubscription_1 = require("./Subscriptions/EventSubChannelPredictionBeginSubscription");
var EventSubChannelPredictionEndSubscription_1 = require("./Subscriptions/EventSubChannelPredictionEndSubscription");
var EventSubChannelPredictionLockSubscription_1 = require("./Subscriptions/EventSubChannelPredictionLockSubscription");
var EventSubChannelPredictionProgressSubscription_1 = require("./Subscriptions/EventSubChannelPredictionProgressSubscription");
var EventSubChannelRaidSubscription_1 = require("./Subscriptions/EventSubChannelRaidSubscription");
var EventSubChannelRedemptionAddSubscription_1 = require("./Subscriptions/EventSubChannelRedemptionAddSubscription");
var EventSubChannelRedemptionUpdateSubscription_1 = require("./Subscriptions/EventSubChannelRedemptionUpdateSubscription");
var EventSubChannelRewardAddSubscription_1 = require("./Subscriptions/EventSubChannelRewardAddSubscription");
var EventSubChannelRewardRemoveSubscription_1 = require("./Subscriptions/EventSubChannelRewardRemoveSubscription");
var EventSubChannelRewardUpdateSubscription_1 = require("./Subscriptions/EventSubChannelRewardUpdateSubscription");
var EventSubChannelSubscriptionEndSubscription_1 = require("./Subscriptions/EventSubChannelSubscriptionEndSubscription");
var EventSubChannelSubscriptionGiftSubscription_1 = require("./Subscriptions/EventSubChannelSubscriptionGiftSubscription");
var EventSubChannelSubscriptionMessageSubscription_1 = require("./Subscriptions/EventSubChannelSubscriptionMessageSubscription");
var EventSubChannelSubscriptionSubscription_1 = require("./Subscriptions/EventSubChannelSubscriptionSubscription");
var EventSubChannelUnbanSubscription_1 = require("./Subscriptions/EventSubChannelUnbanSubscription");
var EventSubChannelUpdateSubscription_1 = require("./Subscriptions/EventSubChannelUpdateSubscription");
var EventSubExtensionBitsTransactionCreateSubscription_1 = require("./Subscriptions/EventSubExtensionBitsTransactionCreateSubscription");
var EventSubStreamOfflineSubscription_1 = require("./Subscriptions/EventSubStreamOfflineSubscription");
var EventSubStreamOnlineSubscription_1 = require("./Subscriptions/EventSubStreamOnlineSubscription");
var EventSubUserAuthorizationRevokeSubscription_1 = require("./Subscriptions/EventSubUserAuthorizationRevokeSubscription");
var EventSubUserUpdateSubscription_1 = require("./Subscriptions/EventSubUserUpdateSubscription");
var numberRegex = /^\d+$/;
/** @private */
var EventSubBase = /** @class */ (function () {
    function EventSubBase(apiClient, secret, config) {
        this._subscriptions = new Map();
        this._twitchSubscriptions = new Map();
        this._readyToSubscribe = false;
        if (apiClient.tokenType !== 'app') {
            throw new twitch_auth_1.InvalidTokenTypeError('EventSub requires app access tokens to work; please use the ClientCredentialsAuthProvider in your API client.');
        }
        this._apiClient = apiClient;
        this._secret = secret;
        this._logger = new logger_1.Logger(tslib_1.__assign({ name: 'twitch-eventsub', emoji: true }, config === null || config === void 0 ? void 0 : config.logger));
    }
    /**
     * Subscribes to events representing a stream going live.
     *
     * @param user The user for which to get notifications about their streams going live.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToStreamOnlineEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToStreamOnlineEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubStreamOnlineSubscription_1.EventSubStreamOnlineSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events representing a stream going offline.
     *
     * @param user The user for which to get notifications about their streams going offline.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToStreamOfflineEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToStreamOfflineEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubStreamOfflineSubscription_1.EventSubStreamOfflineSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events representing a change in channel metadata, e.g. stream title or category.
     *
     * @param user The user for which to get notifications about updates.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelUpdateEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelUpdateSubscription_1.EventSubChannelUpdateSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user following a channel.
     *
     * @param user The user for which to get notifications about their followers.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelFollowEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelFollowEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelFollowSubscription_1.EventSubChannelFollowSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user subscribing to a channel.
     *
     * @param user The user for which to get notifications for about their subscribers.
     * @param handler  The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelSubscriptionEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelSubscriptionEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelSubscriptionSubscription_1.EventSubChannelSubscriptionSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user gifting a subscription to a channel to someone else.
     *
     * @param user The user for which to get notifications for about subscriptions people gift in their channel.
     * @param handler  The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelSubscriptionGiftEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelSubscriptionGiftEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelSubscriptionGiftSubscription_1.EventSubChannelSubscriptionGiftSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user's subscription to a channel being announced.
     *
     * @param user The user for which to get notifications for about announced subscriptions.
     * @param handler  The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelSubscriptionMessageEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelSubscriptionMessageEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelSubscriptionMessageSubscription_1.EventSubChannelSubscriptionMessageSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user's subscription to a channel ending.
     *
     * @param user The user for which to get notifications for about ending subscriptions.
     * @param handler  The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelSubscriptionEndEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelSubscriptionEndEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelSubscriptionEndSubscription_1.EventSubChannelSubscriptionEndSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user cheering some bits.
     *
     * @param user The user for which to get notifications for about cheers they get.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelCheerEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelCheerEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelCheerSubscription_1.EventSubChannelCheerSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user getting banned from a channel.
     *
     * @param user The user for which to get notifications for when users get banned in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelBanEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelBanEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelBanSubscription_1.EventSubChannelBanSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user getting unbanned from a channel.
     *
     * @param user The user for which to get notifications for when users get unbanned in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelUnbanEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelUnbanEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelUnbanSubscription_1.EventSubChannelUnbanSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user getting moderator permissions in a channel.
     *
     * @param user The user for which to get notifications for when users get moderator permissions in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelModeratorAddEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelModeratorAddEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelModeratorAddSubscription_1.EventSubChannelModeratorAddSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user losing moderator permissions in a channel.
     *
     * @param user The user for which to get notifications for when users lose moderator permissions in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelModeratorRemoveEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelModeratorRemoveEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelModeratorRemoveSubscription_1.EventSubChannelModeratorRemoveSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a broadcaster raiding another broadcaster.
     *
     * @param user The broadcaster for which to get outgoing raid notifications.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRaidEventsFrom = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRaidEventsFrom: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRaidSubscription_1.EventSubChannelRaidSubscription, handler, this, userId, 'from')];
            });
        });
    };
    /**
     * Subscribes to events that represent a broadcaster being raided by another broadcaster.
     *
     * @param user The broadcaster for which to get incoming raid notifications.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRaidEventsTo = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRaidEventsTo: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRaidSubscription_1.EventSubChannelRaidSubscription, handler, this, userId, 'to')];
            });
        });
    };
    /**
     * Subscribes to events that represent a Channel Points reward being added to a channel.
     *
     * @param user The user for which to get notifications for when they add a reward to their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRewardAddEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRewardAddEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRewardAddSubscription_1.EventSubChannelRewardAddSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a Channel Points reward being updated.
     *
     * @param user The user for which to get notifications for when they update a reward.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRewardUpdateEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToRewardUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRewardUpdateSubscription_1.EventSubChannelRewardUpdateSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a specific Channel Points reward being updated.
     *
     * @param user The user for which to get notifications for when they update the reward.
     * @param rewardId The ID of the reward for which to get notifications when it is updated.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRewardUpdateEventsForReward = function (user, rewardId, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToRewardUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRewardUpdateSubscription_1.EventSubChannelRewardUpdateSubscription, handler, this, userId, rewardId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a Channel Points reward being removed.
     *
     * @param user The user for which to get notifications for when they remove a reward.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRewardRemoveEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToRewardRemoveEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRewardRemoveSubscription_1.EventSubChannelRewardRemoveSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a specific Channel Points reward being removed.
     *
     * @param user The user for which to get notifications for when they remove the reward.
     * @param rewardId The ID of the reward to get notifications for when it is removed.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRewardRemoveEventsForReward = function (user, rewardId, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToRewardRemoveEventsForReward: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRewardRemoveSubscription_1.EventSubChannelRewardRemoveSubscription, handler, this, userId, rewardId)];
            });
        });
    };
    /**
     * Subscribes to events that represents a Channel Points reward being redeemed.
     *
     * @param user The user for which to get notifications for when their rewards are redeemed.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRedemptionAddEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRedemptionEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRedemptionAddSubscription_1.EventSubChannelRedemptionAddSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a specific Channel Points reward being redeemed.
     *
     * @param user The user for which to get notifications when their reward is redeemed.
     * @param rewardId The ID of the reward for which to get notifications when it is redeemed.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRedemptionAddEventsForReward = function (user, rewardId, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToRedemptionAddEventsForReward: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRedemptionAddSubscription_1.EventSubChannelRedemptionAddSubscription, handler, this, userId, rewardId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a Channel Points reward being updated by a broadcaster.
     *
     * @param user The user for which to get notifications for when they update a reward.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRedemptionUpdateEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRedemptionUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRedemptionUpdateSubscription_1.EventSubChannelRedemptionUpdateSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a specific Channel Points reward being updated by a broadcaster.
     *
     * @param user The user for which to get notifications for when they update the reward.
     * @param rewardId The ID of the reward for which to get notifications when it gets updated.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRedemptionUpdateEventsForReward = function (user, rewardId, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRedemptionUpdateEventsForReward: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRedemptionUpdateSubscription_1.EventSubChannelRedemptionUpdateSubscription, handler, this, userId, rewardId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a poll starting in a channel.
     *
     * @param user The broadcaster for which to receive poll begin events.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelPollBeginEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var broadcasterId;
            return tslib_1.__generator(this, function (_a) {
                broadcasterId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(broadcasterId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelPollBeginEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelPollBeginSubscription_1.EventSubChannelPollBeginSubscription, handler, this, broadcasterId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a poll being voted on in a channel.
     *
     * @param user The broadcaster for which to receive poll progress events.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelPollProgressEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var broadcasterId;
            return tslib_1.__generator(this, function (_a) {
                broadcasterId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(broadcasterId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelPollProgressEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelPollProgressSubscription_1.EventSubChannelPollProgressSubscription, handler, this, broadcasterId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a poll ending in a channel.
     *
     * @param user The broadcaster for which to receive poll end events.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelPollEndEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var broadcasterId;
            return tslib_1.__generator(this, function (_a) {
                broadcasterId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(broadcasterId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelPollEndEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelPollEndSubscription_1.EventSubChannelPollEndSubscription, handler, this, broadcasterId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a prediction starting in a channel.
     *
     * @param user The broadcaster for which to receive prediction begin events.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelPredictionBeginEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var broadcasterId;
            return tslib_1.__generator(this, function (_a) {
                broadcasterId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(broadcasterId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelPredictionBeginEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelPredictionBeginSubscription_1.EventSubChannelPredictionBeginSubscription, handler, this, broadcasterId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a prediction being voted on in a channel.
     *
     * @param user The broadcaster for which to receive prediction progress events.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelPredictionProgressEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var broadcasterId;
            return tslib_1.__generator(this, function (_a) {
                broadcasterId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(broadcasterId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelPredictionProgressEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelPredictionProgressSubscription_1.EventSubChannelPredictionProgressSubscription, handler, this, broadcasterId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a prediction being locked in a channel.
     *
     * @param user The broadcaster for which to receive prediction lock events.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelPredictionLockEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var broadcasterId;
            return tslib_1.__generator(this, function (_a) {
                broadcasterId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(broadcasterId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelPredictionLockEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelPredictionLockSubscription_1.EventSubChannelPredictionLockSubscription, handler, this, broadcasterId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a prediction ending in a channel.
     *
     * @param user The broadcaster for which to receive prediction end events.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelPredictionEndEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var broadcasterId;
            return tslib_1.__generator(this, function (_a) {
                broadcasterId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(broadcasterId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelPredictionEndEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelPredictionEndSubscription_1.EventSubChannelPredictionEndSubscription, handler, this, broadcasterId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a Hype Train beginning.
     *
     * @param user The user for which to get notifications about Hype Trains in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelHypeTrainBeginEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelHypeTrainBeginEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelHypeTrainBeginSubscription_1.EventSubChannelHypeTrainBeginSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent progress in a Hype Train in a channel.
     *
     * @param user The user for which to get notifications about Hype Trains in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelHypeTrainProgressEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelHypeTrainProgressEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelHypeTrainProgressSubscription_1.EventSubChannelHypeTrainProgressSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent the end of a Hype Train in a channel.
     *
     * @param user The user for which to get notifications about Hype Trains in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelHypeTrainEndEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelHypeTrainEndEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelHypeTrainEndSubscription_1.EventSubChannelHypeTrainEndSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a Bits transaction in an extension.
     *
     * @param clientId The Client ID of the extension for which to get notifications for about Bits transactions.
     * @param handler  The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToExtensionBitsTransactionCreateEvents = function (clientId, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._genericSubscribe(EventSubExtensionBitsTransactionCreateSubscription_1.EventSubExtensionBitsTransactionCreateSubscription, handler, this, clientId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user revoking authorization from an application.
     *
     * @param clientId The Client ID for which to get notifications about authorization revocations.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToUserAuthorizationRevokeEvents = function (clientId, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._genericSubscribe(EventSubUserAuthorizationRevokeSubscription_1.EventSubUserAuthorizationRevokeSubscription, handler, this, clientId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user updating their account details.
     *
     * @param user The user for which to get notifications about account updates.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToUserUpdateEvents = function (user, handler) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = twitch_common_1.extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToUserUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubUserUpdateSubscription_1.EventSubUserUpdateSubscription, handler, this, userId)];
            });
        });
    };
    /** @private */
    EventSubBase.prototype._buildHookUrl = function (id) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var hostName, pathPrefix;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getHostName()];
                    case 1:
                        hostName = _b.sent();
                        return [4 /*yield*/, this.getPathPrefix()];
                    case 2:
                        pathPrefix = (_a = (_b.sent())) === null || _a === void 0 ? void 0 : _a.replace(/^\/|\/$/, '');
                        return [2 /*return*/, "https://" + hostName + (pathPrefix ? '/' : '') + (pathPrefix !== null && pathPrefix !== void 0 ? pathPrefix : '') + "/" + id];
                }
            });
        });
    };
    /** @private */
    EventSubBase.prototype._dropSubscription = function (id) {
        this._subscriptions.delete(id);
    };
    /** @private */
    EventSubBase.prototype._dropTwitchSubscription = function (id) {
        this._twitchSubscriptions.delete(id);
    };
    /** @private */
    EventSubBase.prototype._registerTwitchSubscription = function (id, data) {
        this._twitchSubscriptions.set(id, data);
    };
    EventSubBase.prototype._resumeExistingSubscriptions = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var subscriptions, urlPrefix;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._apiClient.helix.eventSub.getSubscriptionsPaginated().getAll()];
                    case 1:
                        subscriptions = _a.sent();
                        return [4 /*yield*/, this._buildHookUrl('')];
                    case 2:
                        urlPrefix = _a.sent();
                        this._twitchSubscriptions = new Map(subscriptions
                            .map(function (sub) {
                            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                            if (sub._transport.method === 'webhook') {
                                var url = sub._transport.callback;
                                if (url.startsWith(urlPrefix)) {
                                    var id = url.slice(urlPrefix.length);
                                    return [id, sub];
                                }
                            }
                            return undefined;
                        })
                            .filter(function (x) { return !!x; }));
                        return [4 /*yield*/, Promise.all(tslib_1.__spread(this._subscriptions).map(function (_a) {
                                var _b = tslib_1.__read(_a, 2), subId = _b[0], sub = _b[1];
                                return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_c) {
                                    return [2 /*return*/, sub.start(this._twitchSubscriptions.get(subId))];
                                }); });
                            }))];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    EventSubBase.prototype._createHandleRequest = function () {
        var _this = this;
        return function (req, res, next) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var id, subscription, twitchSubscription, type, messageId, timestamp, body, algoAndSignature, verified, data, verificationBody;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        id = req.param.id;
                        subscription = this._subscriptions.get(id);
                        twitchSubscription = this._twitchSubscriptions.get(id);
                        type = req.headers['twitch-eventsub-message-type'];
                        if (!subscription) return [3 /*break*/, 2];
                        messageId = req.headers['twitch-eventsub-message-id'];
                        timestamp = req.headers['twitch-eventsub-message-timestamp'];
                        return [4 /*yield*/, raw_body_1.default(req, true)];
                    case 1:
                        body = _a.sent();
                        algoAndSignature = req.headers['twitch-eventsub-message-signature'];
                        if (algoAndSignature === undefined) {
                            this._logger.warn("Dropping unsigned message for action " + type + " of event: " + id);
                            res.writeHead(410);
                            res.end();
                        }
                        else {
                            verified = subscription._verifyData(messageId, timestamp, body, algoAndSignature);
                            if (verified) {
                                data = JSON.parse(body);
                                if (type === 'webhook_callback_verification') {
                                    verificationBody = data;
                                    subscription._verify();
                                    if (twitchSubscription) {
                                        twitchSubscription._status = 'enabled';
                                    }
                                    res.setHeader('Content-Length', verificationBody.challenge.length);
                                    res.writeHead(200, undefined);
                                    res.end(verificationBody.challenge);
                                    this._logger.debug("Successfully subscribed to event: " + id);
                                }
                                else if (type === 'notification') {
                                    subscription._handleData(data.event);
                                    res.writeHead(202);
                                    res.end();
                                }
                                else {
                                    this._logger.warn("Unknown action " + type + " for event: " + id);
                                    res.writeHead(400);
                                    res.end();
                                }
                            }
                            else {
                                this._logger.warn("Could not verify action " + type + " of event: " + id);
                                res.writeHead(410);
                                res.end();
                            }
                        }
                        return [3 /*break*/, 3];
                    case 2:
                        this._logger.warn("Action " + type + " of unknown event attempted: " + id);
                        res.writeHead(410);
                        res.end();
                        _a.label = 3;
                    case 3:
                        next();
                        return [2 /*return*/];
                }
            });
        }); };
    };
    EventSubBase.prototype._genericSubscribe = function (clazz, handler, client) {
        var params = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            params[_i - 3] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var subscription;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        subscription = new (clazz.bind.apply(clazz, tslib_1.__spread([void 0, handler, client], params)))();
                        if (!this._readyToSubscribe) return [3 /*break*/, 2];
                        return [4 /*yield*/, subscription.start(this._twitchSubscriptions.get(subscription.id))];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        this._subscriptions.set(subscription.id, subscription);
                        return [2 /*return*/, subscription];
                }
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.Enumerable(false)
    ], EventSubBase.prototype, "_subscriptions", void 0);
    tslib_1.__decorate([
        shared_utils_1.Enumerable(false)
    ], EventSubBase.prototype, "_twitchSubscriptions", void 0);
    tslib_1.__decorate([
        shared_utils_1.Enumerable(false)
    ], EventSubBase.prototype, "_apiClient", void 0);
    tslib_1.__decorate([
        shared_utils_1.Enumerable(false)
    ], EventSubBase.prototype, "_secret", void 0);
    return EventSubBase;
}());
exports.EventSubBase = EventSubBase;
