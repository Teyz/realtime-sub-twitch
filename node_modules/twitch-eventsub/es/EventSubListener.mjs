import { __awaiter, __decorate, __extends, __generator, __read, __spread } from "tslib";
import { Enumerable } from '@d-fischer/shared-utils';
import { Server } from 'httpanda';
import { rtfm } from 'twitch-common';
import { EventSubBase } from "./EventSubBase.mjs";
/**
 * A listener for the Twitch EventSub event distribution mechanism.
 *
 * @hideProtected
 * @inheritDoc
 */
var EventSubListener = /** @class */ (function (_super) {
    __extends(EventSubListener, _super);
    /**
     * Creates a new EventSub listener.
     *
     * @param apiClient The ApiClient instance to use for user info and API requests.
     * @param secret The secret for Twitch to sign payloads with.
     * @param adapter The connection adapter.
     * @param config
     *
     * @expandParams
     */
    function EventSubListener(apiClient, adapter, secret, config) {
        var _this = _super.call(this, apiClient, secret, config) || this;
        _this._adapter = adapter;
        return _this;
    }
    /**
     * Starts the backing server and listens to incoming EventSub notifications.
     */
    EventSubListener.prototype.listen = function (port) {
        var _a;
        return __awaiter(this, void 0, Promise, function () {
            var server, adapterListenerPort, listenerPort;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this._server) {
                            throw new Error('Trying to listen while already listening');
                        }
                        server = this._adapter.createHttpServer();
                        this._server = new Server({
                            server: server,
                            onError: function (e, req) {
                                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                                if (e.code === 404) {
                                    _this._logger.warn("Access to unknown URL/method attempted: " + req.method + " " + req.url);
                                }
                            }
                        });
                        // needs to be first in chain but run last, for proper logging of status
                        this._server.use(function (req, res, next) {
                            setImmediate(function () {
                                _this._logger.debug(req.method + " " + req.path + " - " + res.statusCode);
                            });
                            next();
                        });
                        this._server.post('/:id', this._createHandleRequest());
                        return [4 /*yield*/, this._adapter.getListenerPort()];
                    case 1:
                        adapterListenerPort = _b.sent();
                        if (adapterListenerPort && port) {
                            this._logger.warn("Your passed port (" + port + ") is being ignored because the adapter has overridden it.\nListening on port " + adapterListenerPort + " instead.");
                        }
                        listenerPort = (_a = adapterListenerPort !== null && adapterListenerPort !== void 0 ? adapterListenerPort : port) !== null && _a !== void 0 ? _a : 443;
                        return [4 /*yield*/, this._server.listen(listenerPort)];
                    case 2:
                        _b.sent();
                        this._readyToSubscribe = true;
                        this._logger.info("Listening on port " + listenerPort);
                        return [4 /*yield*/, this._resumeExistingSubscriptions()];
                    case 3:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Resumes subscriptions that are already registered with Twitch.
     *
     * @deprecated No replacement; this should only be used with middleware.
     */
    EventSubListener.prototype.resumeExistingSubscriptions = function () {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._resumeExistingSubscriptions()];
            });
        });
    };
    /**
     * Stops the backing server, suspending all active subscriptions.
     */
    EventSubListener.prototype.unlisten = function () {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._server) {
                            throw new Error('Trying to unlisten while not listening');
                        }
                        return [4 /*yield*/, Promise.all(__spread(this._subscriptions.values()).map(function (sub) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2 /*return*/, sub.suspend()];
                            }); }); }))];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this._server.close()];
                    case 2:
                        _a.sent();
                        this._server = undefined;
                        this._readyToSubscribe = false;
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Applies middleware that handles EventSub notifications to a connect-compatible app (like express).
     *
     * The express app should be started before this.
     *
     * @param app The app the middleware should be applied to.
     *
     * @deprecated Use {@EventSubMiddleware#applyToApp} instead.
     */
    EventSubListener.prototype.applyMiddleware = function (app) {
        return __awaiter(this, void 0, Promise, function () {
            var pathPrefix, paramParser, requestHandler;
            return __generator(this, function (_a) {
                pathPrefix = this._adapter.pathPrefix;
                if (pathPrefix) {
                    pathPrefix = "/" + pathPrefix.replace(/^\/|\/$/, '');
                }
                paramParser = function (req, res, next) {
                    var _a = __read(req.path.split('/'), 2), id = _a[1];
                    req.param = req.params = { id: id };
                    next();
                };
                requestHandler = this._createHandleRequest();
                if (pathPrefix) {
                    app.use(pathPrefix, paramParser, requestHandler);
                }
                else {
                    app.use(paramParser, requestHandler);
                }
                // stub to fix subscription registration
                this._readyToSubscribe = true;
                return [2 /*return*/];
            });
        });
    };
    EventSubListener.prototype.getHostName = function () {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._adapter.getHostName()];
            });
        });
    };
    EventSubListener.prototype.getPathPrefix = function () {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._adapter.pathPrefix];
            });
        });
    };
    __decorate([
        Enumerable(false)
    ], EventSubListener.prototype, "_server", void 0);
    EventSubListener = __decorate([
        rtfm('twitch-eventsub', 'EventSubListener')
    ], EventSubListener);
    return EventSubListener;
}(EventSubBase));
export { EventSubListener };
