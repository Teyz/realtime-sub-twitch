import { __assign, __awaiter, __decorate, __generator, __read, __spread } from "tslib";
import { Logger } from '@d-fischer/logger';
import getRawBody from '@d-fischer/raw-body';
import { Enumerable } from '@d-fischer/shared-utils';
import { InvalidTokenTypeError } from 'twitch-auth';
import { extractUserId } from 'twitch-common';
import { EventSubChannelBanSubscription } from "./Subscriptions/EventSubChannelBanSubscription.mjs";
import { EventSubChannelCheerSubscription } from "./Subscriptions/EventSubChannelCheerSubscription.mjs";
import { EventSubChannelFollowSubscription } from "./Subscriptions/EventSubChannelFollowSubscription.mjs";
import { EventSubChannelHypeTrainBeginSubscription } from "./Subscriptions/EventSubChannelHypeTrainBeginSubscription.mjs";
import { EventSubChannelHypeTrainEndSubscription } from "./Subscriptions/EventSubChannelHypeTrainEndSubscription.mjs";
import { EventSubChannelHypeTrainProgressSubscription } from "./Subscriptions/EventSubChannelHypeTrainProgressSubscription.mjs";
import { EventSubChannelModeratorAddSubscription } from "./Subscriptions/EventSubChannelModeratorAddSubscription.mjs";
import { EventSubChannelModeratorRemoveSubscription } from "./Subscriptions/EventSubChannelModeratorRemoveSubscription.mjs";
import { EventSubChannelPollBeginSubscription } from "./Subscriptions/EventSubChannelPollBeginSubscription.mjs";
import { EventSubChannelPollEndSubscription } from "./Subscriptions/EventSubChannelPollEndSubscription.mjs";
import { EventSubChannelPollProgressSubscription } from "./Subscriptions/EventSubChannelPollProgressSubscription.mjs";
import { EventSubChannelPredictionBeginSubscription } from "./Subscriptions/EventSubChannelPredictionBeginSubscription.mjs";
import { EventSubChannelPredictionEndSubscription } from "./Subscriptions/EventSubChannelPredictionEndSubscription.mjs";
import { EventSubChannelPredictionLockSubscription } from "./Subscriptions/EventSubChannelPredictionLockSubscription.mjs";
import { EventSubChannelPredictionProgressSubscription } from "./Subscriptions/EventSubChannelPredictionProgressSubscription.mjs";
import { EventSubChannelRaidSubscription } from "./Subscriptions/EventSubChannelRaidSubscription.mjs";
import { EventSubChannelRedemptionAddSubscription } from "./Subscriptions/EventSubChannelRedemptionAddSubscription.mjs";
import { EventSubChannelRedemptionUpdateSubscription } from "./Subscriptions/EventSubChannelRedemptionUpdateSubscription.mjs";
import { EventSubChannelRewardAddSubscription } from "./Subscriptions/EventSubChannelRewardAddSubscription.mjs";
import { EventSubChannelRewardRemoveSubscription } from "./Subscriptions/EventSubChannelRewardRemoveSubscription.mjs";
import { EventSubChannelRewardUpdateSubscription } from "./Subscriptions/EventSubChannelRewardUpdateSubscription.mjs";
import { EventSubChannelSubscriptionEndSubscription } from "./Subscriptions/EventSubChannelSubscriptionEndSubscription.mjs";
import { EventSubChannelSubscriptionGiftSubscription } from "./Subscriptions/EventSubChannelSubscriptionGiftSubscription.mjs";
import { EventSubChannelSubscriptionMessageSubscription } from "./Subscriptions/EventSubChannelSubscriptionMessageSubscription.mjs";
import { EventSubChannelSubscriptionSubscription } from "./Subscriptions/EventSubChannelSubscriptionSubscription.mjs";
import { EventSubChannelUnbanSubscription } from "./Subscriptions/EventSubChannelUnbanSubscription.mjs";
import { EventSubChannelUpdateSubscription } from "./Subscriptions/EventSubChannelUpdateSubscription.mjs";
import { EventSubExtensionBitsTransactionCreateSubscription } from "./Subscriptions/EventSubExtensionBitsTransactionCreateSubscription.mjs";
import { EventSubStreamOfflineSubscription } from "./Subscriptions/EventSubStreamOfflineSubscription.mjs";
import { EventSubStreamOnlineSubscription } from "./Subscriptions/EventSubStreamOnlineSubscription.mjs";
import { EventSubUserAuthorizationRevokeSubscription } from "./Subscriptions/EventSubUserAuthorizationRevokeSubscription.mjs";
import { EventSubUserUpdateSubscription } from "./Subscriptions/EventSubUserUpdateSubscription.mjs";
var numberRegex = /^\d+$/;
/** @private */
var EventSubBase = /** @class */ (function () {
    function EventSubBase(apiClient, secret, config) {
        this._subscriptions = new Map();
        this._twitchSubscriptions = new Map();
        this._readyToSubscribe = false;
        if (apiClient.tokenType !== 'app') {
            throw new InvalidTokenTypeError('EventSub requires app access tokens to work; please use the ClientCredentialsAuthProvider in your API client.');
        }
        this._apiClient = apiClient;
        this._secret = secret;
        this._logger = new Logger(__assign({ name: 'twitch-eventsub', emoji: true }, config === null || config === void 0 ? void 0 : config.logger));
    }
    /**
     * Subscribes to events representing a stream going live.
     *
     * @param user The user for which to get notifications about their streams going live.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToStreamOnlineEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToStreamOnlineEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubStreamOnlineSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events representing a stream going offline.
     *
     * @param user The user for which to get notifications about their streams going offline.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToStreamOfflineEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToStreamOfflineEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubStreamOfflineSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events representing a change in channel metadata, e.g. stream title or category.
     *
     * @param user The user for which to get notifications about updates.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelUpdateEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelUpdateSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user following a channel.
     *
     * @param user The user for which to get notifications about their followers.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelFollowEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelFollowEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelFollowSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user subscribing to a channel.
     *
     * @param user The user for which to get notifications for about their subscribers.
     * @param handler  The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelSubscriptionEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelSubscriptionEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelSubscriptionSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user gifting a subscription to a channel to someone else.
     *
     * @param user The user for which to get notifications for about subscriptions people gift in their channel.
     * @param handler  The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelSubscriptionGiftEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelSubscriptionGiftEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelSubscriptionGiftSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user's subscription to a channel being announced.
     *
     * @param user The user for which to get notifications for about announced subscriptions.
     * @param handler  The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelSubscriptionMessageEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelSubscriptionMessageEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelSubscriptionMessageSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user's subscription to a channel ending.
     *
     * @param user The user for which to get notifications for about ending subscriptions.
     * @param handler  The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelSubscriptionEndEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelSubscriptionEndEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelSubscriptionEndSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user cheering some bits.
     *
     * @param user The user for which to get notifications for about cheers they get.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelCheerEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelCheerEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelCheerSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user getting banned from a channel.
     *
     * @param user The user for which to get notifications for when users get banned in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelBanEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelBanEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelBanSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user getting unbanned from a channel.
     *
     * @param user The user for which to get notifications for when users get unbanned in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelUnbanEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelUnbanEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelUnbanSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user getting moderator permissions in a channel.
     *
     * @param user The user for which to get notifications for when users get moderator permissions in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelModeratorAddEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelModeratorAddEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelModeratorAddSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user losing moderator permissions in a channel.
     *
     * @param user The user for which to get notifications for when users lose moderator permissions in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelModeratorRemoveEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelModeratorRemoveEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelModeratorRemoveSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a broadcaster raiding another broadcaster.
     *
     * @param user The broadcaster for which to get outgoing raid notifications.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRaidEventsFrom = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRaidEventsFrom: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRaidSubscription, handler, this, userId, 'from')];
            });
        });
    };
    /**
     * Subscribes to events that represent a broadcaster being raided by another broadcaster.
     *
     * @param user The broadcaster for which to get incoming raid notifications.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRaidEventsTo = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRaidEventsTo: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRaidSubscription, handler, this, userId, 'to')];
            });
        });
    };
    /**
     * Subscribes to events that represent a Channel Points reward being added to a channel.
     *
     * @param user The user for which to get notifications for when they add a reward to their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRewardAddEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRewardAddEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRewardAddSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a Channel Points reward being updated.
     *
     * @param user The user for which to get notifications for when they update a reward.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRewardUpdateEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToRewardUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRewardUpdateSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a specific Channel Points reward being updated.
     *
     * @param user The user for which to get notifications for when they update the reward.
     * @param rewardId The ID of the reward for which to get notifications when it is updated.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRewardUpdateEventsForReward = function (user, rewardId, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToRewardUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRewardUpdateSubscription, handler, this, userId, rewardId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a Channel Points reward being removed.
     *
     * @param user The user for which to get notifications for when they remove a reward.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRewardRemoveEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToRewardRemoveEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRewardRemoveSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a specific Channel Points reward being removed.
     *
     * @param user The user for which to get notifications for when they remove the reward.
     * @param rewardId The ID of the reward to get notifications for when it is removed.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRewardRemoveEventsForReward = function (user, rewardId, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToRewardRemoveEventsForReward: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRewardRemoveSubscription, handler, this, userId, rewardId)];
            });
        });
    };
    /**
     * Subscribes to events that represents a Channel Points reward being redeemed.
     *
     * @param user The user for which to get notifications for when their rewards are redeemed.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRedemptionAddEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRedemptionEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRedemptionAddSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a specific Channel Points reward being redeemed.
     *
     * @param user The user for which to get notifications when their reward is redeemed.
     * @param rewardId The ID of the reward for which to get notifications when it is redeemed.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRedemptionAddEventsForReward = function (user, rewardId, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToRedemptionAddEventsForReward: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRedemptionAddSubscription, handler, this, userId, rewardId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a Channel Points reward being updated by a broadcaster.
     *
     * @param user The user for which to get notifications for when they update a reward.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRedemptionUpdateEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRedemptionUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRedemptionUpdateSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a specific Channel Points reward being updated by a broadcaster.
     *
     * @param user The user for which to get notifications for when they update the reward.
     * @param rewardId The ID of the reward for which to get notifications when it gets updated.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelRedemptionUpdateEventsForReward = function (user, rewardId, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRedemptionUpdateEventsForReward: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRedemptionUpdateSubscription, handler, this, userId, rewardId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a poll starting in a channel.
     *
     * @param user The broadcaster for which to receive poll begin events.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelPollBeginEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var broadcasterId;
            return __generator(this, function (_a) {
                broadcasterId = extractUserId(user);
                if (!numberRegex.test(broadcasterId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelPollBeginEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelPollBeginSubscription, handler, this, broadcasterId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a poll being voted on in a channel.
     *
     * @param user The broadcaster for which to receive poll progress events.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelPollProgressEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var broadcasterId;
            return __generator(this, function (_a) {
                broadcasterId = extractUserId(user);
                if (!numberRegex.test(broadcasterId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelPollProgressEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelPollProgressSubscription, handler, this, broadcasterId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a poll ending in a channel.
     *
     * @param user The broadcaster for which to receive poll end events.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelPollEndEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var broadcasterId;
            return __generator(this, function (_a) {
                broadcasterId = extractUserId(user);
                if (!numberRegex.test(broadcasterId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelPollEndEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelPollEndSubscription, handler, this, broadcasterId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a prediction starting in a channel.
     *
     * @param user The broadcaster for which to receive prediction begin events.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelPredictionBeginEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var broadcasterId;
            return __generator(this, function (_a) {
                broadcasterId = extractUserId(user);
                if (!numberRegex.test(broadcasterId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelPredictionBeginEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelPredictionBeginSubscription, handler, this, broadcasterId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a prediction being voted on in a channel.
     *
     * @param user The broadcaster for which to receive prediction progress events.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelPredictionProgressEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var broadcasterId;
            return __generator(this, function (_a) {
                broadcasterId = extractUserId(user);
                if (!numberRegex.test(broadcasterId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelPredictionProgressEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelPredictionProgressSubscription, handler, this, broadcasterId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a prediction being locked in a channel.
     *
     * @param user The broadcaster for which to receive prediction lock events.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelPredictionLockEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var broadcasterId;
            return __generator(this, function (_a) {
                broadcasterId = extractUserId(user);
                if (!numberRegex.test(broadcasterId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelPredictionLockEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelPredictionLockSubscription, handler, this, broadcasterId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a prediction ending in a channel.
     *
     * @param user The broadcaster for which to receive prediction end events.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelPredictionEndEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var broadcasterId;
            return __generator(this, function (_a) {
                broadcasterId = extractUserId(user);
                if (!numberRegex.test(broadcasterId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelPredictionEndEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelPredictionEndSubscription, handler, this, broadcasterId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a Hype Train beginning.
     *
     * @param user The user for which to get notifications about Hype Trains in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelHypeTrainBeginEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelHypeTrainBeginEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelHypeTrainBeginSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent progress in a Hype Train in a channel.
     *
     * @param user The user for which to get notifications about Hype Trains in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelHypeTrainProgressEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelHypeTrainProgressEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelHypeTrainProgressSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent the end of a Hype Train in a channel.
     *
     * @param user The user for which to get notifications about Hype Trains in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToChannelHypeTrainEndEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelHypeTrainEndEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelHypeTrainEndSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a Bits transaction in an extension.
     *
     * @param clientId The Client ID of the extension for which to get notifications for about Bits transactions.
     * @param handler  The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToExtensionBitsTransactionCreateEvents = function (clientId, handler) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._genericSubscribe(EventSubExtensionBitsTransactionCreateSubscription, handler, this, clientId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user revoking authorization from an application.
     *
     * @param clientId The Client ID for which to get notifications about authorization revocations.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToUserAuthorizationRevokeEvents = function (clientId, handler) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._genericSubscribe(EventSubUserAuthorizationRevokeSubscription, handler, this, clientId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user updating their account details.
     *
     * @param user The user for which to get notifications about account updates.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubBase.prototype.subscribeToUserUpdateEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToUserUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubUserUpdateSubscription, handler, this, userId)];
            });
        });
    };
    /** @private */
    EventSubBase.prototype._buildHookUrl = function (id) {
        var _a;
        return __awaiter(this, void 0, Promise, function () {
            var hostName, pathPrefix;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getHostName()];
                    case 1:
                        hostName = _b.sent();
                        return [4 /*yield*/, this.getPathPrefix()];
                    case 2:
                        pathPrefix = (_a = (_b.sent())) === null || _a === void 0 ? void 0 : _a.replace(/^\/|\/$/, '');
                        return [2 /*return*/, "https://" + hostName + (pathPrefix ? '/' : '') + (pathPrefix !== null && pathPrefix !== void 0 ? pathPrefix : '') + "/" + id];
                }
            });
        });
    };
    /** @private */
    EventSubBase.prototype._dropSubscription = function (id) {
        this._subscriptions.delete(id);
    };
    /** @private */
    EventSubBase.prototype._dropTwitchSubscription = function (id) {
        this._twitchSubscriptions.delete(id);
    };
    /** @private */
    EventSubBase.prototype._registerTwitchSubscription = function (id, data) {
        this._twitchSubscriptions.set(id, data);
    };
    EventSubBase.prototype._resumeExistingSubscriptions = function () {
        return __awaiter(this, void 0, Promise, function () {
            var subscriptions, urlPrefix;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._apiClient.helix.eventSub.getSubscriptionsPaginated().getAll()];
                    case 1:
                        subscriptions = _a.sent();
                        return [4 /*yield*/, this._buildHookUrl('')];
                    case 2:
                        urlPrefix = _a.sent();
                        this._twitchSubscriptions = new Map(subscriptions
                            .map(function (sub) {
                            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                            if (sub._transport.method === 'webhook') {
                                var url = sub._transport.callback;
                                if (url.startsWith(urlPrefix)) {
                                    var id = url.slice(urlPrefix.length);
                                    return [id, sub];
                                }
                            }
                            return undefined;
                        })
                            .filter(function (x) { return !!x; }));
                        return [4 /*yield*/, Promise.all(__spread(this._subscriptions).map(function (_a) {
                                var _b = __read(_a, 2), subId = _b[0], sub = _b[1];
                                return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_c) {
                                    return [2 /*return*/, sub.start(this._twitchSubscriptions.get(subId))];
                                }); });
                            }))];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    EventSubBase.prototype._createHandleRequest = function () {
        var _this = this;
        return function (req, res, next) { return __awaiter(_this, void 0, void 0, function () {
            var id, subscription, twitchSubscription, type, messageId, timestamp, body, algoAndSignature, verified, data, verificationBody;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        id = req.param.id;
                        subscription = this._subscriptions.get(id);
                        twitchSubscription = this._twitchSubscriptions.get(id);
                        type = req.headers['twitch-eventsub-message-type'];
                        if (!subscription) return [3 /*break*/, 2];
                        messageId = req.headers['twitch-eventsub-message-id'];
                        timestamp = req.headers['twitch-eventsub-message-timestamp'];
                        return [4 /*yield*/, getRawBody(req, true)];
                    case 1:
                        body = _a.sent();
                        algoAndSignature = req.headers['twitch-eventsub-message-signature'];
                        if (algoAndSignature === undefined) {
                            this._logger.warn("Dropping unsigned message for action " + type + " of event: " + id);
                            res.writeHead(410);
                            res.end();
                        }
                        else {
                            verified = subscription._verifyData(messageId, timestamp, body, algoAndSignature);
                            if (verified) {
                                data = JSON.parse(body);
                                if (type === 'webhook_callback_verification') {
                                    verificationBody = data;
                                    subscription._verify();
                                    if (twitchSubscription) {
                                        twitchSubscription._status = 'enabled';
                                    }
                                    res.setHeader('Content-Length', verificationBody.challenge.length);
                                    res.writeHead(200, undefined);
                                    res.end(verificationBody.challenge);
                                    this._logger.debug("Successfully subscribed to event: " + id);
                                }
                                else if (type === 'notification') {
                                    subscription._handleData(data.event);
                                    res.writeHead(202);
                                    res.end();
                                }
                                else {
                                    this._logger.warn("Unknown action " + type + " for event: " + id);
                                    res.writeHead(400);
                                    res.end();
                                }
                            }
                            else {
                                this._logger.warn("Could not verify action " + type + " of event: " + id);
                                res.writeHead(410);
                                res.end();
                            }
                        }
                        return [3 /*break*/, 3];
                    case 2:
                        this._logger.warn("Action " + type + " of unknown event attempted: " + id);
                        res.writeHead(410);
                        res.end();
                        _a.label = 3;
                    case 3:
                        next();
                        return [2 /*return*/];
                }
            });
        }); };
    };
    EventSubBase.prototype._genericSubscribe = function (clazz, handler, client) {
        var params = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            params[_i - 3] = arguments[_i];
        }
        return __awaiter(this, void 0, Promise, function () {
            var subscription;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        subscription = new (clazz.bind.apply(clazz, __spread([void 0, handler, client], params)))();
                        if (!this._readyToSubscribe) return [3 /*break*/, 2];
                        return [4 /*yield*/, subscription.start(this._twitchSubscriptions.get(subscription.id))];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        this._subscriptions.set(subscription.id, subscription);
                        return [2 /*return*/, subscription];
                }
            });
        });
    };
    __decorate([
        Enumerable(false)
    ], EventSubBase.prototype, "_subscriptions", void 0);
    __decorate([
        Enumerable(false)
    ], EventSubBase.prototype, "_twitchSubscriptions", void 0);
    __decorate([
        Enumerable(false)
    ], EventSubBase.prototype, "_apiClient", void 0);
    __decorate([
        Enumerable(false)
    ], EventSubBase.prototype, "_secret", void 0);
    return EventSubBase;
}());
export { EventSubBase };
